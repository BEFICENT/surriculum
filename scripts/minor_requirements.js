// minor_requirements.js
// Minor requirements can be stored either:
// - Legacy: `requirements/minors.jsonl` (single snapshot term)
// - Term-specific: `requirements/minors/<TERM>.jsonl` (recommended)
//
// This loader supports both and exposes helpers to load a specific term and
// to discover which term codes are available.

function parseJsonlLines(text) {
  const trimmed = (text || '').trim();
  if (!trimmed) return [];
  return trimmed.split(/\r?\n/).map(l => l.trim()).filter(Boolean).map(l => JSON.parse(l));
}

function parseJsonOrJsonl(text) {
  const trimmed = (text || '').trim();
  if (!trimmed) return null;
  try {
    return JSON.parse(trimmed);
  } catch (_) {
    try {
      return parseJsonlLines(trimmed);
    } catch (_) {
      return null;
    }
  }
}

function toRecordArray(parsed) {
  if (!parsed) return [];
  if (Array.isArray(parsed)) return parsed;
  if (parsed && typeof parsed === 'object') return Object.values(parsed);
  return [];
}

function loadMinorRequirementsForTerm(termCode) {
  const code = String(termCode || '').trim();
  const termPaths = code
    ? [`./requirements/minors/${code}.jsonl`, `./requirements/minors/${code}.json`]
    : [];
  const fallbackPaths = ['./requirements/minors.jsonl', './requirements/minors.json'];
  const paths = termPaths.concat(fallbackPaths);
  const tryLoad = (p) => {
    try {
      const xhr = new XMLHttpRequest();
      xhr.open('GET', p, false);
      xhr.overrideMimeType('application/json');
      xhr.send(null);
      if (xhr.status === 200 || xhr.status === 0) {
        const parsed = parseJsonOrJsonl(xhr.responseText);
        return toRecordArray(parsed);
      }
    } catch (_) {}
    return null;
  };

  let data = null;
  for (const p of paths) {
    data = tryLoad(p);
    if (data) break;
  }
  const byCode = {};
  if (Array.isArray(data)) {
    for (const rec of data) {
      if (!rec || typeof rec !== 'object') continue;
      const code = rec.minor;
      if (!code) continue;
      byCode[String(code)] = rec;
    }
  }
  return byCode;
}

function loadMinorRequirements() {
  return loadMinorRequirementsForTerm('');
}

function loadMinorTermCodes() {
  // Preferred source: `requirements/minors/terms.jsonl` (one record per term),
  // generated by the scraper.
  const paths = ['./requirements/minors/terms.jsonl', './requirements/minors/terms.json'];
  for (const p of paths) {
    try {
      const xhr = new XMLHttpRequest();
      xhr.open('GET', p, false);
      xhr.overrideMimeType('application/json');
      xhr.send(null);
      if (!(xhr.status === 200 || xhr.status === 0)) continue;
      const parsed = parseJsonOrJsonl(xhr.responseText);
      const arr = toRecordArray(parsed);
      const out = [];
      for (const rec of arr) {
        if (typeof rec === 'string' && /^\d{6}$/.test(rec)) out.push(rec);
        else if (rec && typeof rec === 'object' && rec.term && /^\d{6}$/.test(String(rec.term))) out.push(String(rec.term));
      }
      if (out.length) {
        return Array.from(new Set(out)).sort((a, b) => (parseInt(b, 10) - parseInt(a, 10)));
      }
    } catch (_) {}
  }

  // Fallback: derive term codes from the legacy snapshot file's `term` fields.
  try {
    const req = loadMinorRequirements();
    const codes = [];
    for (const k of Object.keys(req || {})) {
      const r = req[k];
      if (!r || typeof r !== 'object') continue;
      if (r.term && typeof window !== 'undefined' && typeof window.termNameToCode === 'function') {
        const c = window.termNameToCode(String(r.term));
        if (c && /^\d{6}$/.test(c)) codes.push(c);
      }
    }
    if (codes.length) {
      return Array.from(new Set(codes)).sort((a, b) => (parseInt(b, 10) - parseInt(a, 10)));
    }
  } catch (_) {}

  return [];
}

const minorRequirements = loadMinorRequirements() || {};
if (typeof window !== 'undefined') {
  window.minorRequirements = minorRequirements;
  window.loadMinorRequirements = loadMinorRequirements;
  window.loadMinorRequirementsForTerm = loadMinorRequirementsForTerm;
  window.loadMinorTermCodes = loadMinorTermCodes;
}
