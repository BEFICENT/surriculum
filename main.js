// Import statements removed. `s_curriculum` is expected to be defined
// globally by s_curriculum.js when loaded as a non-module script.

// Remove ES module imports for graduation_check. The functions
// displayGraduationResults and displaySummary will be attached to the
// global window object by graduation_check.js when loaded as a
// non-module script.

let course_data;
//can only be CS, BIO, MAT, EE, ME, IE, ECON, DSA, MAN, PSIR, PSY, VACD:
let initial_major_chosen = 'CS'
let saveInterval;

const _planIdForSession = (() => {
    try {
        if (typeof window !== 'undefined' && window.planStorage && typeof window.planStorage.getActivePlanId === 'function') {
            return window.planStorage.getActivePlanId();
        }
    } catch (_) {}
    return null;
})();

function planGetItem(key) {
    try {
        if (typeof window !== 'undefined' && window.planStorage && typeof window.planStorage.getItem === 'function') {
            return window.planStorage.getItem(key, _planIdForSession || undefined);
        }
    } catch (_) {}
    try { return localStorage.getItem(key); } catch (_) {}
    return null;
}

function planSetItem(key, value) {
    try {
        if (typeof window !== 'undefined' && window.planStorage && typeof window.planStorage.setItem === 'function') {
            window.planStorage.setItem(key, value, _planIdForSession || undefined);
            return;
        }
    } catch (_) {}
    try { localStorage.setItem(key, value); } catch (_) {}
}

function planRemoveItem(key) {
    try {
        if (typeof window !== 'undefined' && window.planStorage && typeof window.planStorage.removeItem === 'function') {
            window.planStorage.removeItem(key, _planIdForSession || undefined);
            return;
        }
    } catch (_) {}
    try { localStorage.removeItem(key); } catch (_) {}
}

function escapeHtml(value) {
    return String(value ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

async function uiAlert(title, bodyHtml) {
    try {
        const ui = (typeof window !== 'undefined') ? window.uiModal : null;
        if (ui && typeof ui.alert === 'function') {
            await ui.alert(title || 'Notice', bodyHtml || '');
            return;
        }
    } catch (_) {}
    // No browser alerts: fallback to console only.
    try { console.warn('[uiAlert]', title, bodyHtml); } catch (_) {}
}

async function uiConfirm(title, bodyHtml, options) {
    try {
        const ui = (typeof window !== 'undefined') ? window.uiModal : null;
        if (ui && typeof ui.confirm === 'function') {
            return await ui.confirm(title || 'Confirm', bodyHtml || '', options || {});
        }
    } catch (_) {}
    try { console.warn('[uiConfirm]', title, bodyHtml); } catch (_) {}
    return false;
}

if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js');
    });
}


function SUrriculum(major_chosen_by_user) {
    function parseJsonOrJsonl(text) {
        const trimmed = (text || '').trim();
        if (!trimmed) return null;
        try {
            return JSON.parse(trimmed);
        } catch (_) {
            try {
                const lines = trimmed.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
                return lines.map(line => JSON.parse(line));
            } catch (_) {
                return null;
            }
        }
    }

    function parseMajorsByTerm(text) {
        const parsed = parseJsonOrJsonl(text);
        if (!parsed) return {};
        if (Array.isArray(parsed)) {
            const out = {};
            for (const rec of parsed) {
                if (!rec || typeof rec !== 'object') continue;
                const term = rec.term;
                const majors = rec.majors;
                if (!term || !Array.isArray(majors)) continue;
                out[String(term)] = majors;
            }
            return out;
        }
        if (typeof parsed === 'object') return parsed;
        return {};
    }

    /**
     * Attempt to fetch course data for the given major. By default the data
     * is expected to live under `./courses/${major}.jsonl`, but in some
     * deployments legacy `.json` files are present, or the files are present
     * at the root (e.g., `./CS.jsonl`).
     * This helper first tries the canonical location and falls back to the
     * root if the first fetch fails. It always returns a resolved Promise
     * with the parsed JSON or rejects if neither location is found.
     *
     * @param {string} major
     * @returns {Promise<Object[]>}
     */
    // Load mapping of available majors per term. Generated by the scraping
    // scripts and stored in courses/terms.jsonl. This allows the major
    // selector to display only the programs offered in the chosen year.
    let majorsByTerm = {};
    try {
        const termPaths = ['./courses/terms.jsonl', './courses/terms.json'];
        for (const p of termPaths) {
            const xhr = new XMLHttpRequest();
            xhr.open('GET', p, false);
            xhr.overrideMimeType('application/json');
            xhr.send(null);
            if (xhr.status === 200 || xhr.status === 0) {
                const parsed = parseMajorsByTerm(xhr.responseText);
                if (parsed && typeof parsed === 'object' && Object.keys(parsed).length > 0) {
                    majorsByTerm = parsed;
                    break;
                }
            }
        }
    } catch (_) {}
    const defaultMajors = majorsByTerm['default'] || ['BIO','CS','EE','IE','MAT','ME','ECON','DSA','MAN','PSIR','PSY','VACD'];
    function getMajorsForTerm(code) {
        return majorsByTerm[code] || defaultMajors;
    }

    // Build entry term options from the scraped term manifest so admit term
    // selectors only show terms for which data exists. Cap the upper bound
    // dynamically based on the device's current term.
    try {
        const termCodeKeys = Object.keys(majorsByTerm || {}).filter(k => /^\d{6}$/.test(k));
        const termCodes = termCodeKeys.map(k => parseInt(k, 10)).filter(n => !isNaN(n));
        termCodes.sort((a, b) => b - a);
        const minCode = 201901; // fixed minimum (Fall 2019-2020)
        const maxAvailable = termCodes.length ? termCodes[0] : minCode;
        let currentCode = 0;
        try {
            const ctName = (typeof window !== 'undefined' && window.currentTermName) ? window.currentTermName : '';
            currentCode = parseInt(termNameToCode(ctName), 10) || 0;
        } catch (_) {}
        const maxCode = Math.max(maxAvailable, currentCode);
        const entryCodes = termCodes.filter(c => c >= minCode && c <= maxCode);
        const entryNames = entryCodes.map(c => termCodeToName(String(c)));
        if (Array.isArray(entryNames) && entryNames.length) {
            entryTerms = entryNames;
        }
    } catch (_) {}

    // Load course list for a specific major and term code (e.g. "202301").
    // Files are stored under courses/<term>/<major>.jsonl. Fallback to the
    // root if the term-specific file is not found to preserve backward
    // compatibility with older deployments.
    function fetchCourseData(major, termCode) {
        // Build relative paths for the course JSON files. We avoid
        // computing absolute file URLs for file:// origins because
        // Chrome treats different file paths as different origins,
        // blocking cross-file requests. Using relative paths keeps
        // requests within the same origin (the directory of index.html).
        const primaryBase = `courses/${termCode}/${major}`;
        const fallbackBase = `courses/${major}`;
        const rootBase = `${major}`;

        // Helper to synchronously read JSON via XMLHttpRequest.  When
        // accessing resources under the file:// protocol many browsers
        // block fetch() due to CORS or security restrictions.  A
        // synchronous XHR is still permitted in these scenarios and
        // returns status 0 on success.  This helper returns a parsed
        // array of courses or null if the file could not be read.
        const tryRead = (path) => {
            try {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', path, false);
                xhr.overrideMimeType('application/json');
                xhr.send(null);
                if (xhr.status === 200 || xhr.status === 0) {
                    const parsed = parseJsonOrJsonl(xhr.responseText);
                    if (parsed === null) return null;
                    return Array.isArray(parsed) ? parsed : [];
                }
            } catch (_) {
                // ignore errors and fall through
            }
            return null;
        };

        // Paths to attempt loading the course data.  We try the term
        // specific location first, followed by a fallback (no term) and
        // finally the root.  This preserves compatibility with older
        // deployments where the JSON files live in the top level.
        const paths = [
            `${primaryBase}.jsonl`,
            `${primaryBase}.json`,
            `${fallbackBase}.jsonl`,
            `${fallbackBase}.json`,
            `${rootBase}.jsonl`,
            `${rootBase}.json`,
        ];

        // If running under file://, prefer synchronous XHR to bypass
        // fetch() restrictions.  We iterate each candidate path and
        // return on the first successful read.  If all attempts
        // fail, return an empty array.  For http(s) origins we still
        // attempt fetch() but only after synchronous reads fail.
        return (async () => {
            for (const p of paths) {
                const read = tryRead(p);
                if (read) {
                    return read;
                }
            }
            // If synchronous reads failed (likely under http(s)), fall
            // back to fetch.  Check res.ok and parse JSON.  Note: fetch
            // does not reject on 404; we must inspect ok.  If the
            // parsed value is not an array, return an empty list.
            for (const p of paths) {
                try {
                    const res = await fetch(p);
                    if (res.ok) {
                        const text = await res.text();
                        const data = parseJsonOrJsonl(text);
                        if (data === null) continue;
                        return Array.isArray(data) ? data : [];
                    }
                } catch (_) {
                    // ignore errors and continue
                }
            }
            return [];
        })();
    }
    // Determine entry terms for main and double majors from localStorage. The
    // terms are stored as display strings (e.g. "Fall 2023-2024"). We convert
    // them to numeric codes to locate the scraped JSON files.
    let entryTermName = planGetItem('entryTerm') || '';
    if (!entryTermName || (Array.isArray(entryTerms) && entryTerms.length && !entryTerms.includes(entryTermName))) {
        entryTermName = entryTerms[0];
    }
    let entryTermDMName = planGetItem('entryTermDM') || entryTermName;
    if (!entryTermDMName || (Array.isArray(entryTerms) && entryTerms.length && !entryTerms.includes(entryTermDMName))) {
        entryTermDMName = entryTermName;
    }

    // Minor admit term options: prefer the scraped minor term manifest if
    // available; otherwise fall back to the general entry terms list.
    let minorEntryTerms = entryTerms;
    try {
        const codes = (typeof window !== 'undefined' && typeof window.loadMinorTermCodes === 'function')
            ? window.loadMinorTermCodes()
            : [];
        if (Array.isArray(codes) && codes.length) {
            const names = codes.map(c => termCodeToName(String(c))).filter(Boolean);
            if (names.length) minorEntryTerms = names;
        }
    } catch (_) {}

    const pickValidMinorTermName = (candidate, fallback) => {
        const c = String(candidate || '').trim();
        if (!c) return fallback;
        if (Array.isArray(minorEntryTerms) && minorEntryTerms.length && !minorEntryTerms.includes(c)) return fallback;
        return c;
    };
    const minorDefaultTermName = (() => {
        if (Array.isArray(minorEntryTerms) && minorEntryTerms.length) {
            if (minorEntryTerms.includes(entryTermName)) return entryTermName;
            return minorEntryTerms[0];
        }
        return entryTermName;
    })();
    const legacyMinorTermName = planGetItem('entryTermMinor') || '';
    const entryTermMinor1Name = pickValidMinorTermName(planGetItem('entryTermMinor1') || legacyMinorTermName, minorDefaultTermName);
    const entryTermMinor2Name = pickValidMinorTermName(planGetItem('entryTermMinor2') || legacyMinorTermName, minorDefaultTermName);
    const entryTermMinor3Name = pickValidMinorTermName(planGetItem('entryTermMinor3') || legacyMinorTermName, minorDefaultTermName);
    try {
        if (!planGetItem('major')) planSetItem('major', major_chosen_by_user);
        if (!planGetItem('entryTerm')) planSetItem('entryTerm', entryTermName);
        if (!planGetItem('entryTermDM')) planSetItem('entryTermDM', entryTermDMName);
        if (!planGetItem('entryTermMinor1')) planSetItem('entryTermMinor1', entryTermMinor1Name);
        if (!planGetItem('entryTermMinor2')) planSetItem('entryTermMinor2', entryTermMinor2Name);
        if (!planGetItem('entryTermMinor3')) planSetItem('entryTermMinor3', entryTermMinor3Name);
        // Keep the legacy key in sync (older exports/backwards compatibility).
        if (!planGetItem('entryTermMinor') || planGetItem('entryTermMinor') !== entryTermMinor1Name) {
            planSetItem('entryTermMinor', entryTermMinor1Name);
        }
    } catch (_) {}
    const entryTermCode = termNameToCode(entryTermName);
    const entryTermDMCode = termNameToCode(entryTermDMName);
    const entryTermMinor1Code = termNameToCode(entryTermMinor1Name);
    const entryTermMinor2Code = termNameToCode(entryTermMinor2Name);
    const entryTermMinor3Code = termNameToCode(entryTermMinor3Name);

    // Storage for the double major's course data.  It will be populated when
    // the user selects a double major via setDoubleMajor().
    let doubleMajorCourseData = [];

    fetchCourseData(major_chosen_by_user, entryTermCode)
    .then(async json => {
        // If the course list could not be loaded, log a warning instead of
        // blocking the UI with an alert.  In some environments the
        // synchronous XHR may fail to resolve file:// URLs even when
        // the JSON exists, producing a false negative.  Logging a
        // warning allows the app to continue and display whatever
        // information could be retrieved.
        if (!json || json.length === 0) {
            console.warn('No course data available for ' + major_chosen_by_user + ' in ' + entryTermName + '.');
        }
    //START OF PROGRAM
        let change_major_element = document.querySelector('.change_major');
        let etElem = document.querySelector('.entryTerm');
        let etDmElem = document.querySelector('.entryTermDM');
        const etMinor1Elem = document.getElementById('minorTerm1');
        const etMinor2Elem = document.getElementById('minorTerm2');
        const etMinor3Elem = document.getElementById('minorTerm3');
        let dmElem = document.querySelector('.doubleMajor');
        const dmControlsRow = document.getElementById('doubleMajorControlsRow');
        const dmButtonRow = document.getElementById('doubleMajorButtonRow');
        const addDmBtn = document.getElementById('addDoubleMajorBtn');
        const minor1Row = document.getElementById('minor1Row');
        const minor2Row = document.getElementById('minor2Row');
        const minor3Row = document.getElementById('minor3Row');
        const addMinorRow = document.getElementById('addMinorRow');
        const addMinorBtn = document.getElementById('addMinorBtn');
        const minor1Select = document.getElementById('minor1');
        const minor2Select = document.getElementById('minor2');
        const minor3Select = document.getElementById('minor3');

        const setDmUiVisible = (visible) => {
            try {
                if (visible) {
                    if (dmControlsRow) dmControlsRow.classList.remove('is-hidden');
                    if (dmButtonRow) dmButtonRow.classList.add('is-hidden');
                } else {
                    if (dmControlsRow) dmControlsRow.classList.add('is-hidden');
                    if (dmButtonRow) dmButtonRow.classList.remove('is-hidden');
                }
            } catch (_) {}
        };

        const setMinorRowVisible = (row, visible) => {
            try {
                if (!row) return;
                if (visible) row.classList.remove('is-hidden');
                else row.classList.add('is-hidden');
            } catch (_) {}
        };
        // Populate and bind dropdown controls for major and entry terms
        if (change_major_element && change_major_element.tagName === 'SELECT') {
            const majorsList = getMajorsForTerm(entryTermCode);
            change_major_element.innerHTML = majorsList.map(m => `<option value="${m}">${m}</option>`).join('');
            change_major_element.value = major_chosen_by_user;
            change_major_element.addEventListener('change', function(e) {
                planSetItem('major', e.target.value);
                location.reload();
            });
        }
        if (etElem && etElem.tagName === 'SELECT') {
            etElem.innerHTML = entryTerms.map(t => `<option value="${t}">${t}</option>`).join('');
            etElem.value = entryTermName;
            etElem.addEventListener('change', function(e) {
                planSetItem('entryTerm', e.target.value);
                location.reload();
            });
        }
        if (dmElem && dmElem.tagName === 'SELECT') {
            const dmList = ['None'].concat(getMajorsForTerm(entryTermDMCode));
            dmElem.innerHTML = dmList.map(m => `<option value="${m === 'None' ? '' : m}">${m}</option>`).join('');
            dmElem.value = planGetItem('doubleMajor') || '';
            dmElem.addEventListener('change', function(e) {
                const val = e.target.value;
                if (val) {
                    planSetItem('doubleMajor', val);
                    try { localStorage.setItem('showDoubleMajorControls', 'true'); } catch (_) {}
                } else {
                    planRemoveItem('doubleMajor');
                    // Collapse the DM controls after the user explicitly sets it to None.
                    try { localStorage.setItem('showDoubleMajorControls', 'false'); } catch (_) {}
                }
                location.reload();
            });
        }
        if (etDmElem && etDmElem.tagName === 'SELECT') {
            etDmElem.innerHTML = entryTerms.map(t => `<option value="${t}">${t}</option>`).join('');
            etDmElem.value = entryTermDMName;
            etDmElem.addEventListener('change', function(e) {
                planSetItem('entryTermDM', e.target.value);
                location.reload();
            });
        }
        const bindMinorTermSelect = (elem, key, value) => {
            if (!elem || elem.tagName !== 'SELECT') return;
            elem.innerHTML = (minorEntryTerms || []).map(t => `<option value="${t}">${t}</option>`).join('');
            elem.value = value || '';
            elem.addEventListener('change', function(e) {
                planSetItem(key, e.target.value);
                // Keep legacy key aligned to the first minor term.
                if (key === 'entryTermMinor1') planSetItem('entryTermMinor', e.target.value);
                location.reload();
            });
        };
        bindMinorTermSelect(etMinor1Elem, 'entryTermMinor1', entryTermMinor1Name);
        bindMinorTermSelect(etMinor2Elem, 'entryTermMinor2', entryTermMinor2Name);
        bindMinorTermSelect(etMinor3Elem, 'entryTermMinor3', entryTermMinor3Name);

        // Double major UI: show dropdowns by default on first visit, but allow
        // collapsing them into a single "Add Double Major" button when the DM
        // is None/empty.
        try {
            const hasDM = !!(planGetItem('doubleMajor') || '');
            let showPref = false;
            try {
                const stored = localStorage.getItem('showDoubleMajorControls');
                if (stored !== null) showPref = stored === 'true';
            } catch (_) {}
            if (hasDM) {
                setDmUiVisible(true);
                try { localStorage.setItem('showDoubleMajorControls', 'true'); } catch (_) {}
            } else {
                setDmUiVisible(showPref);
            }
            if (addDmBtn) {
                addDmBtn.addEventListener('click', function() {
                    setDmUiVisible(true);
                    try { localStorage.setItem('showDoubleMajorControls', 'true'); } catch (_) {}
                    try { if (dmElem) dmElem.focus(); } catch (_) {}
                });
            }
        } catch (_) {}

        // Minor UI (up to 3): similar UX to double major, but allows multiple.
        try {
            // Load term-specific minor requirements if available.
            try {
                // Use the first minor term as the default catalog view for the dropdowns.
                if (typeof window !== 'undefined' && typeof window.loadMinorRequirementsForTerm === 'function' && entryTermMinor1Code) {
                    window.minorRequirements = window.loadMinorRequirementsForTerm(entryTermMinor1Code) || {};
                }
            } catch (_) {}
            const minorReq = (typeof window !== 'undefined' && window.minorRequirements) ? window.minorRequirements : {};
            const minorList = Object.values(minorReq || {}).filter(Boolean).sort((a, b) => {
                const an = String(a.name || a.minor || '');
                const bn = String(b.name || b.minor || '');
                return an.localeCompare(bn);
            });
            const shortenMinorLabel = (fullName) => {
                const raw = String(fullName || '').trim();
                if (!raw) return '';
                const MAX = 44;
                if (raw.length <= MAX) return raw;
                let s = raw;
                s = s.replace(/\bMinor Program\b/ig, '').replace(/\bProgram\b/ig, '').replace(/\bMinor\b/ig, '');
                s = s.replace(/\bin\b/ig, ' ').replace(/\s{2,}/g, ' ').trim();
                s = s.replace(/\band\b/ig, '&');
                if (s.length <= MAX) return s;
                if (s.includes('(')) {
                    const before = s.split('(')[0].trim();
                    if (before.length >= 10 && before.length < s.length) s = before;
                }
                if (s.length <= MAX) return s;
                return s.slice(0, MAX - 3).trimEnd() + '...';
            };

            const optionsHtml = ['<option value=\"\">None</option>'].concat(
                minorList.map(rec => {
                    const full = String(rec.name || rec.minor || '').trim() || String(rec.minor || '');
                    const short = shortenMinorLabel(full) || full;
                    return `<option value=\"${escapeHtml(rec.minor)}\" title=\"${escapeHtml(full)}\">${escapeHtml(short)}</option>`;
                })
            ).join('');

            const getMinor = (k) => {
                try { return planGetItem(k) || ''; } catch (_) {}
                return '';
            };
            const setMinor = (k, v) => {
                try {
                    if (v) planSetItem(k, v);
                    else planRemoveItem(k);
                } catch (_) {}
            };
            const getMinorTerm = (slot) => {
                try {
                    const k = `entryTermMinor${slot}`;
                    const v = planGetItem(k) || '';
                    if (v) return v;
                } catch (_) {}
                if (slot === 1) return entryTermMinor1Name;
                if (slot === 2) return entryTermMinor2Name;
                if (slot === 3) return entryTermMinor3Name;
                return minorDefaultTermName;
            };
            const setMinorTerm = (slot, value) => {
                try {
                    const k = `entryTermMinor${slot}`;
                    planSetItem(k, value || minorDefaultTermName);
                    if (slot === 1) planSetItem('entryTermMinor', value || minorDefaultTermName);
                } catch (_) {}
            };

            const saved1 = getMinor('minor1');
            const saved2 = getMinor('minor2');
            const saved3 = getMinor('minor3');
            const hasAny = !!(saved1 || saved2 || saved3);

            let showPref = false; // hide minor controls on first visit
            try {
                const stored = localStorage.getItem('showMinorControls');
                if (stored !== null) showPref = stored === 'true';
            } catch (_) {}

            const ensureSelect = (sel, value) => {
                if (!sel || sel.tagName !== 'SELECT') return;
                sel.innerHTML = optionsHtml;
                sel.value = value || '';
            };
            ensureSelect(minor1Select, saved1);
            ensureSelect(minor2Select, saved2);
            ensureSelect(minor3Select, saved3);

            // Visibility: if no minors selected, obey preference; otherwise show
            // the rows needed to display the selected minors.
            if (!hasAny && !showPref) {
                setMinorRowVisible(minor1Row, false);
                setMinorRowVisible(minor2Row, false);
                setMinorRowVisible(minor3Row, false);
            } else {
                setMinorRowVisible(minor1Row, true);
                setMinorRowVisible(minor2Row, !!saved2);
                setMinorRowVisible(minor3Row, !!saved3);
            }

            const updateAddMinorBtn = () => {
                try {
                    if (!addMinorBtn) return;
                    const r1 = minor1Row && !minor1Row.classList.contains('is-hidden');
                    const r2 = minor2Row && !minor2Row.classList.contains('is-hidden');
                    const r3 = minor3Row && !minor3Row.classList.contains('is-hidden');
                    const atMax = !!(r1 && r2 && r3);
                    addMinorBtn.disabled = atMax;
                    if (addMinorRow) {
                        if (atMax) addMinorRow.classList.add('is-hidden');
                        else addMinorRow.classList.remove('is-hidden');
                    }
                } catch (_) {}
            };
            updateAddMinorBtn();

            const onMinorChange = (slot, value) => {
                // Persist and keep minors compact: if an earlier slot is cleared,
                // shift later minors up.
                const v = value || '';
                if (slot === 1) {
                    if (!v) {
                        const next1 = saved2 || '';
                        const next2 = saved3 || '';
                        setMinor('minor1', next1);
                        setMinor('minor2', next2);
                        setMinor('minor3', '');
                        setMinorTerm(1, getMinorTerm(2));
                        setMinorTerm(2, getMinorTerm(3));
                        setMinorTerm(3, minorDefaultTermName);
                        const stillHasAny = !!(next1 || next2);
                        try { localStorage.setItem('showMinorControls', stillHasAny ? 'true' : 'false'); } catch (_) {}
                    } else {
                        setMinor('minor1', v);
                        try { localStorage.setItem('showMinorControls', 'true'); } catch (_) {}
                    }
                } else if (slot === 2) {
                    if (!v) {
                        setMinor('minor2', saved3 || '');
                        setMinor('minor3', '');
                        setMinorTerm(2, getMinorTerm(3));
                        setMinorTerm(3, minorDefaultTermName);
                    } else {
                        setMinor('minor2', v);
                    }
                    try { localStorage.setItem('showMinorControls', 'true'); } catch (_) {}
                } else if (slot === 3) {
                    if (!v) setMinor('minor3', '');
                    else setMinor('minor3', v);
                    try { localStorage.setItem('showMinorControls', 'true'); } catch (_) {}
                }
                location.reload();
            };

            if (minor1Select) {
                minor1Select.addEventListener('change', (e) => onMinorChange(1, e.target.value));
            }
            if (minor2Select) {
                minor2Select.addEventListener('change', (e) => onMinorChange(2, e.target.value));
            }
            if (minor3Select) {
                minor3Select.addEventListener('change', (e) => onMinorChange(3, e.target.value));
            }

            if (addMinorBtn) {
                addMinorBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    try { localStorage.setItem('showMinorControls', 'true'); } catch (_) {}
                    // Reveal the next hidden minor row.
                    if (minor1Row && minor1Row.classList.contains('is-hidden')) setMinorRowVisible(minor1Row, true);
                    else if (minor2Row && minor2Row.classList.contains('is-hidden')) setMinorRowVisible(minor2Row, true);
                    else if (minor3Row && minor3Row.classList.contains('is-hidden')) setMinorRowVisible(minor3Row, true);
                    updateAddMinorBtn();
                    try {
                        if (minor1Row && !minor1Row.classList.contains('is-hidden') && minor1Select && !minor1Select.value) minor1Select.focus();
                        else if (minor2Row && !minor2Row.classList.contains('is-hidden') && minor2Select && !minor2Select.value) minor2Select.focus();
                        else if (minor3Row && !minor3Row.classList.contains('is-hidden') && minor3Select && !minor3Select.value) minor3Select.focus();
                    } catch (_) {}
                });
            }
        } catch (_) {}

    course_data = json;

    // ----------------------------------------------------------------------
    // Load any previously defined custom courses for this major from
    // localStorage. Custom courses are stored as an array of course
    // objects keyed by `customCourses_<major>`. These custom courses are
    // appended to the fetched course_data. This allows users to define
    // additional courses specific to a major without modifying the
    // underlying JSON files. On first use, the key may not exist so
    // JSON.parse on an empty string would throw; guard accordingly.
    try {
        const customKey = 'customCourses_' + major_chosen_by_user;
        const stored = planGetItem(customKey);
        if (stored) {
            const parsed = JSON.parse(stored);
            if (Array.isArray(parsed)) {
                course_data = course_data.concat(parsed);
            }
        }
    } catch (err) {
        console.error('Failed to load custom courses:', err);
    }

    // Preload double major data so that courses unique to the second major
    // are available when reloading semesters from localStorage.
    let savedDMPref = '';
    try {
        savedDMPref = planGetItem('doubleMajor') || '';
    } catch (_) {}
    if (savedDMPref) {
        const dmData = await fetchCourseData(savedDMPref, entryTermDMCode);
        if (Array.isArray(dmData)) {
            doubleMajorCourseData = dmData.slice();
        } else {
            doubleMajorCourseData = [];
        }
        try {
            const keyDM = 'customCourses_' + savedDMPref;
            const storedDM = planGetItem(keyDM);
            if (storedDM) {
                const parsedDM = JSON.parse(storedDM);
                if (Array.isArray(parsedDM)) {
                    doubleMajorCourseData = doubleMajorCourseData.concat(parsedDM);
                }
            }
        } catch (_) {}
    }

    // Preload minor course lists (up to 3). Minor catalogs are stored under
    // courses/minors/<PROGRAM>.jsonl and are merged into the Add Course
    // dropdown similarly to double majors.
    function fetchMinorCourseData(minorProgram, termCode) {
        if (!minorProgram) return [];
        const tc = String(termCode || '').trim();
        const paths = [
            ...(tc ? [`courses/minors/${tc}/${minorProgram}.jsonl`, `courses/minors/${tc}/${minorProgram}.json`] : []),
            `courses/minors/${minorProgram}.jsonl`,
            `courses/minors/${minorProgram}.json`,
            `${minorProgram}.jsonl`,
            `${minorProgram}.json`,
        ];
        const tryRead = (path) => {
            try {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', path, false);
                xhr.overrideMimeType('application/json');
                xhr.send(null);
                if (xhr.status === 200 || xhr.status === 0) {
                    const parsed = parseJsonOrJsonl(xhr.responseText);
                    if (parsed === null) return null;
                    return Array.isArray(parsed) ? parsed : [];
                }
            } catch (_) {}
            return null;
        };
        for (const p of paths) {
            const read = tryRead(p);
            if (read !== null) return read;
        }
        return [];
    }

    const minorProgramsSet = new Set();
    const minorTermsByCode = {};
    try {
        const m1 = planGetItem('minor1') || '';
        const m2 = planGetItem('minor2') || '';
        const m3 = planGetItem('minor3') || '';
        const t1 = termNameToCode(planGetItem('entryTermMinor1') || entryTermMinor1Name) || entryTermMinor1Code;
        const t2 = termNameToCode(planGetItem('entryTermMinor2') || entryTermMinor2Name) || entryTermMinor2Code;
        const t3 = termNameToCode(planGetItem('entryTermMinor3') || entryTermMinor3Name) || entryTermMinor3Code;
        if (m1) {
            minorProgramsSet.add(m1);
            if (!minorTermsByCode[m1]) minorTermsByCode[m1] = t1;
        }
        if (m2) {
            minorProgramsSet.add(m2);
            if (!minorTermsByCode[m2]) minorTermsByCode[m2] = t2;
        }
        if (m3) {
            minorProgramsSet.add(m3);
            if (!minorTermsByCode[m3]) minorTermsByCode[m3] = t3;
        }
    } catch (_) {}
    const minorPrograms = Array.from(minorProgramsSet);
    const minorCourseDataByCode = {};
    try {
        for (const mp of minorPrograms) {
            const data = fetchMinorCourseData(mp, minorTermsByCode[mp] || entryTermMinor1Code);
            if (Array.isArray(data) && data.length) {
                minorCourseDataByCode[mp] = data.slice();
            } else {
                minorCourseDataByCode[mp] = [];
            }
        }
    } catch (_) {}
    let curriculum = new s_curriculum();
    curriculum.major = major_chosen_by_user;
    curriculum.entryTerm = entryTermCode;
    curriculum.entryTermDM = entryTermDMCode;
    // Backward-compatible field: use Minor 1 term as a "default minor term".
    curriculum.entryTermMinor = entryTermMinor1Code;
    if (savedDMPref) {
        curriculum.doubleMajorCourseData = doubleMajorCourseData;
        curriculum.doubleMajor = savedDMPref;
        curriculum.entryTermDM = entryTermDMCode;
    }
    if (minorPrograms.length) {
        curriculum.minors = minorPrograms.slice();
        curriculum.minorCourseDataByCode = { ...minorCourseDataByCode };
        curriculum.minorTermsByCode = { ...minorTermsByCode };
    } else {
        curriculum.minors = [];
        curriculum.minorCourseDataByCode = {};
        curriculum.minorTermsByCode = {};
    }

    // Expose the curriculum object globally so that helper functions
    // (e.g., isCourseValid and getInfo) can access the double major
    // configuration. This is especially useful for validating courses
    // that belong solely to the double major. Without this, helper
    // functions cannot see doubleMajorCourseData and would reject
    // double-major-specific courses.
    if (typeof window !== 'undefined') {
        window.curriculum = curriculum;
    }
    // Initialize course details toggle state and event
    let showDetails = true;
    try {
        const stored = localStorage.getItem('showCourseDetails');
        if (stored !== null) {
            showDetails = stored === 'true';
        }
    } catch (_) {}
    if (typeof window !== 'undefined') {
        window.showCourseDetails = showDetails;
    }
    const detailsToggle = document.getElementById('courseDetailsToggle');
    if (detailsToggle) {
        detailsToggle.checked = showDetails;
        detailsToggle.addEventListener('change', function(e) {
            const enabled = e.target.checked;
            if (typeof window !== 'undefined') {
                window.showCourseDetails = enabled;
            }
            try { localStorage.setItem('showCourseDetails', enabled ? 'true' : 'false'); } catch (_) {}
            document.dispatchEvent(new Event('courseDetailsToggleChanged'));
        });
    }

    const updateCourseDetailVisibility = () => {
        const show = window.showCourseDetails;
        document.querySelectorAll('.course_bs_credit').forEach(el => {
            el.style.display = show ? '' : 'none';
        });
    };
    document.addEventListener('courseDetailsToggleChanged', updateCourseDetailVisibility);
    updateCourseDetailVisibility();

    let hideTaken = true;
    try {
        const stored = localStorage.getItem('hideTakenCourses');
        if (stored !== null) {
            hideTaken = stored === 'true';
        }
    } catch (_) {}
    if (typeof window !== 'undefined') {
        window.hideTakenCourses = hideTaken;
    }
    const hideToggle = document.getElementById('hideTakenCoursesToggle');
    if (hideToggle) {
        hideToggle.checked = hideTaken;
        hideToggle.addEventListener('change', function(e) {
            const enabled = e.target.checked;
            if (typeof window !== 'undefined') {
                window.hideTakenCourses = enabled;
            }
            try { localStorage.setItem('hideTakenCourses', enabled ? 'true' : 'false'); } catch (_) {}
            document.dispatchEvent(new Event('hideTakenCoursesToggleChanged'));
        });
    }

    let offeredOnly = false;
    try {
        const stored = localStorage.getItem('offeredThisTermOnly');
        if (stored !== null) {
            offeredOnly = stored === 'true';
        }
    } catch (_) {}
    if (typeof window !== 'undefined') {
        window.offeredThisTermOnly = offeredOnly;
    }
    const offeredToggle = document.getElementById('offeredThisTermToggle');
    if (offeredToggle) {
        offeredToggle.checked = offeredOnly;
        offeredToggle.addEventListener('change', function(e) {
            const enabled = e.target.checked;
            if (typeof window !== 'undefined') {
                window.offeredThisTermOnly = enabled;
            }
            try { localStorage.setItem('offeredThisTermOnly', enabled ? 'true' : 'false'); } catch (_) {}
            document.dispatchEvent(new Event('offeredThisTermToggleChanged'));
        });
    }
    try {
        const label = document.getElementById('offeredThisTermLabel');
        const ctName = (typeof window !== 'undefined' && window.currentTermName) ? window.currentTermName : '';
        if (label && ctName) {
            label.textContent = `Only show offered courses in ${ctName}`;
        }
    } catch (_) {}

    let sortByScore = false;
    try {
        const stored = localStorage.getItem('sortBasedOnScore');
        if (stored !== null) {
            sortByScore = stored === 'true';
        }
    } catch (_) {}
    if (typeof window !== 'undefined') {
        window.sortBasedOnScore = sortByScore;
    }
    const sortToggle = document.getElementById('sortByScoreToggle');
    if (sortToggle) {
        sortToggle.checked = sortByScore;
        sortToggle.addEventListener('change', function(e) {
            const enabled = e.target.checked;
            if (typeof window !== 'undefined') {
                window.sortBasedOnScore = enabled;
            }
            try { localStorage.setItem('sortBasedOnScore', enabled ? 'true' : 'false'); } catch (_) {}
            document.dispatchEvent(new Event('sortByScoreToggleChanged'));
        });
    }

    //************************************************

    //Targetting dynamically created elements:
    document.addEventListener('click', function(e){
        dynamic_click(e, curriculum, course_data);
        // Summary/graduation overlays: clicking outside the cards/panels should close.
        try {
            if (e.target && typeof e.target.closest === 'function') {
                const summaryOverlay = e.target.closest('.summary_modal_overlay');
                if (summaryOverlay) {
                    const insideCard = e.target.closest('.summary_modal');
                    const insideMinorPanel = e.target.closest('.summary_minor_panel');
                    const insideMajorPanel = e.target.closest('.summary_major_panel');
                    if (!insideCard && !insideMinorPanel && !insideMajorPanel) {
                        try { document.querySelectorAll('.summary_modal').forEach(function(mod){ mod.remove(); }); } catch {}
                        try { document.querySelectorAll('.summary_modal_overlay').forEach(function(ov){ ov.remove(); }); } catch {}
                    }
                    return;
                }
                const gradOverlay = e.target.closest('.graduation_modal_overlay');
                if (gradOverlay) {
                    const insideGrad = e.target.closest('.graduation_modal');
                    if (!insideGrad) {
                        try{document.querySelector('.graduation_modal').remove();} catch{}
                        try{document.querySelector('.graduation_modal_overlay').remove();} catch{}
                    }
                    return;
                }
            }
        } catch (_) {}
        if (!(e.target.parentNode.classList.contains('summary_modal_child')) &&
            !e.target.classList.contains('summary_modal_child') &&
            !e.target.classList.contains('summary_modal') &&
            !e.target.classList.contains('summary') &&
            !e.target.classList.contains('summary_p')) {
            try { document.querySelectorAll('.summary_modal').forEach(function(mod){ mod.remove(); }); } catch {}
            try { document.querySelectorAll('.summary_modal_overlay').forEach(function(ov){ ov.remove(); }); } catch {}
        }
        if(!(e.target.parentNode.classList.contains('graduation_modal')) && !e.target.classList.contains('graduation_modal') && !e.target.classList.contains('check') && !e.target.parentNode.classList.contains('check')) {
            try{document.querySelector('.graduation_modal').remove();} catch{}
            try{document.querySelector('.graduation_modal_overlay').remove();} catch{}
        }
    });
    document.addEventListener('mouseover', function(e){
        mouseover(e);
        if (e.target.classList.contains('btn'))
        {e.target.style.backgroundColor = '';}
        else if(e.target.parentNode.classList && e.target.parentNode.classList.contains('btn'))
        {e.target.parentNode.style.backgroundColor = '';}
        else
        {
            document.querySelectorAll('.btn').forEach( element => {element.style.backgroundColor = ''});
        }
    })
    document.addEventListener('mouseout', function(e){
        mouseout(e);
        if (e.target.classList.contains('btn'))
        {e.target.style.backgroundColor = '';}
    })

    try {
        if (typeof window !== 'undefined' && typeof window.updateCurrentTermHighlights === 'function') {
            window.updateCurrentTermHighlights();
        }
    } catch (_) {}

    let dragged_item = null;
    document.addEventListener('dragstart', function(e){
        if(e.target.classList.contains("container_semester"))
        {dragged_item = e.target;}
    })
    document.addEventListener('dragover', function(e){
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    })

    document.addEventListener('drop', function(e){
        // Pass course_data to the drop handler so that it can invoke
        // curriculum.recalcEffectiveTypes() when semesters are reordered.
        drop(e, curriculum, dragged_item, course_data);
    })

    // Touch-based dragging support mirrors the desktop drag events so that
    // semesters can be reordered on touch devices.  We leverage touch
    // coordinates on touchend to determine the drop target and prevent the
    // page from scrolling while a semester is being dragged.
    document.addEventListener('touchstart', function(e){
        // Only begin dragging if the user taps the dedicated drag handle.
        const handle = getAncestor(e.target, 'semester_drag');
        if(handle){
            dragged_item = getAncestor(handle, 'container_semester');
        }
    })
    document.addEventListener('touchmove', function(e){
        if(dragged_item){
            // Prevent viewport scrolling while dragging a semester
            e.preventDefault();
        }
    }, {passive:false})
    document.addEventListener('touchend', function(e){
        if(dragged_item){
            const touch = e.changedTouches[0];
            drop(e, curriculum, dragged_item, course_data, {x: touch.clientX, y: touch.clientY});
            dragged_item = null;
        }
    })
    /*
    document.addEventListener("input", function(e){
        if(e.target.classList.contains())
    })*/

    //************************************************************** 

    //NON-DYNAMIC BUTTONS:
    const addSemester = document.querySelector(".addSemester");
    addSemester.addEventListener('click', function(){
        const board = document.querySelector('.board');
        const newContainer = createSemeter(true, [], curriculum, course_data);
        const ghost = document.querySelector('.add-semester-ghost');
        if (ghost && board) {
            board.insertBefore(newContainer, ghost);
            const style = getComputedStyle(newContainer);
            const width = newContainer.offsetWidth + parseInt(style.marginLeft) + parseInt(style.marginRight);
            board.scrollBy({ left: width, behavior: 'smooth' });
        }
    });

    function ensureGhostSemester() {
        const board = document.querySelector('.board');
        if (!board) return;
        let ghost = board.querySelector('.add-semester-ghost');
        if (!ghost) {
            ghost = document.createElement('div');
            ghost.classList.add('add-semester-ghost');
            ghost.textContent = '+ New Semester';
            ghost.addEventListener('click', function() {
                const newContainer = createSemeter(true, [], curriculum, course_data);
                const style = getComputedStyle(newContainer);
                const width = newContainer.offsetWidth + parseInt(style.marginLeft) + parseInt(style.marginRight);
                board.insertBefore(newContainer, ghost);
                board.scrollBy({ left: width, behavior: 'smooth' });
            });
            board.appendChild(ghost);
        }
    }

    // Sidebar collapse toggle
    const sidebar = document.querySelector('.sidebar');
    const sidebarToggle = document.querySelector('.sidebar-toggle');
    if (sidebar && sidebarToggle) {
        sidebarToggle.addEventListener('click', function() {
            sidebar.classList.toggle('collapsed');
        });
    }

    // Enable swipe gestures on touch devices to open/close the sidebar
    if (sidebar) {
        let touchStartX = null;
        let touchStartY = null;

        document.addEventListener('touchstart', function(e){
            if (e.touches.length !== 1) return;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, {passive: true});

        document.addEventListener('touchend', function(e){
            if (touchStartX === null || touchStartY === null) return;
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const diffX = touchEndX - touchStartX;
            const diffY = touchEndY - touchStartY;

            if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 50) {
                if (diffX > 0 && touchStartX < 30 && sidebar.classList.contains('collapsed')) {
                    sidebar.classList.remove('collapsed');
                } else if (diffX < 0 && touchStartX < sidebar.offsetWidth && !sidebar.classList.contains('collapsed')) {
                    sidebar.classList.add('collapsed');
                }
            }

            touchStartX = null;
            touchStartY = null;
        }, {passive: true});
    }

    const auto_add = document.querySelector('.autoAdd');
    auto_add.addEventListener('click', async function(){
        // Check if there are existing semesters
        const semesters = document.querySelectorAll('.semester');
        if (semesters.length > 0) {
            await uiAlert(
                'Cannot add first year courses',
                '<p><strong>Add First Year Courses</strong> only works when no semesters are present.</p><p>Create a new plan or delete existing semesters and try again.</p>'
            );
            return;
        }

        // Determine the user's entry term so that the automatically added
        // semesters start from that term rather than the earliest term in
        // the list (Fall 2019-2020).
        const entryTerm = planGetItem('entryTerm') || entryTerms[0];
        const entryCode = termNameToCode(entryTerm);

        // Helper to compute the next chronological term code
        function nextTermCode(code) {
            const term = code.slice(4);
            const year = parseInt(code.slice(0, 4), 10);
            if (term === '01') return String(year) + '02'; // Fall -> Spring
            // Summer -> Fall of next academic year
            return String(year + 1) + '01';
        }

        const nextCode = nextTermCode(entryCode);
        const nextTerm = termCodeToName(nextCode);

        // Automatically insert the typical first year courses into two semesters.
        let fs_courses = ["MATH101","NS101","SPS101","IF100","TLL101","HIST191","CIP101N"];
        let ss_courses = ["MATH102","NS102","SPS102","AL102","TLL102","HIST192","PROJ201"];

        // Insert the next term first so that the entry term ends up at the top
        // of the board. Pass explicit term names to createSemeter so that the
        // semesters use the correct dates.
        createSemeter(false, ss_courses, curriculum, course_data, [], nextTerm);
        createSemeter(false, fs_courses, curriculum, course_data, [], entryTerm);
    })

    // Older markup wrapped the text inside a <p> tag. Guard against that
    // structure to avoid errors when clicking the button in the new UI.
    const checkText = document.querySelector('.check>p');
    if (checkText) {
        checkText.addEventListener('click', function(){
            document.querySelector('.check').click();
        });
    }
    const check_graduation = document.querySelector('.check');
    check_graduation.addEventListener('click', function(){
        displayGraduationResults(curriculum);
    })

    const summary = document.querySelector('.summary');
    summary.addEventListener('click', function(){
        displaySummary(curriculum, major_chosen_by_user);
    })

    // ----------------------------------------------------------------------
    // Custom Course: create a modal form to let the user define a new
    // course. The new course is stored in localStorage under a key
    // specific to the current major (customCourses_<major>) and added to
    // course_data. Existing datalists are updated so the new course can
    // be selected immediately. Only one custom course modal can be open
    // at a time.
        function showCustomCourseForm(prefill = null, courseObj = null, onSaveCallback = null) {
            // Prevent multiple modals
            if (document.querySelector('.custom_course_modal')) return;

        // Append overlay to body so it covers the full viewport
        const boardDom = document.body;

        // Create overlay container
        const overlay = document.createElement('div');
        overlay.classList.add('custom_course_overlay');

        // Create modal container
        const modal = document.createElement('div');
        modal.classList.add('custom_course_modal');

        // Title
        const title = document.createElement('h3');
        title.innerText = 'Add Custom Course';
        modal.appendChild(title);

        // Helper to create input row
        function createInputRow(labelText, inputType = 'text', placeholder = '', defaultValue = '') {
            const row = document.createElement('div');
            row.classList.add('cc-row');

            const label = document.createElement('label');
            label.innerText = labelText;
            row.appendChild(label);

            const input = document.createElement('input');
            input.type = inputType;
            input.placeholder = placeholder;
            input.value = defaultValue;
            row.appendChild(input);

            return { row, input };
        }

            // Course Code input (e.g., CS101)
            const { row: codeRow, input: codeInput } = createInputRow('Course Code:', 'text', 'e.g. CS300');
            modal.appendChild(codeRow);

            // Course Name input
            const { row: nameRow, input: nameInput } = createInputRow('Course Name:', 'text', 'Course name');
            modal.appendChild(nameRow);

            // SU Credits input
            const { row: suRow, input: suInput } = createInputRow('SU Credits:', 'number', 'e.g. 3');
            modal.appendChild(suRow);

            // ECTS input
            const { row: ectsRow, input: ectsInput } = createInputRow('ECTS:', 'number', 'e.g. 6');
            modal.appendChild(ectsRow);

            // Basic Science credits input
            const { row: bsRow, input: bsInput } = createInputRow('Basic Science credits:', 'number', 'e.g. 0');
            bsInput.value = '0';
            modal.appendChild(bsRow);

            // Engineering credits input
            const { row: engRow, input: engInput } = createInputRow('Engineering credits:', 'number', 'e.g. 0');
            engInput.value = '0';
            modal.appendChild(engRow);

            // EL Type dropdown
            const typeRow = document.createElement('div');
            typeRow.classList.add('cc-row');
            const typeLabel = document.createElement('label');
            typeLabel.innerText = 'Category (EL_Type):';
            typeRow.appendChild(typeLabel);
            const typeSelect = document.createElement('select');
            ['core', 'area', 'university', 'free', 'required', 'none'].forEach(function(opt) {
                const option = document.createElement('option');
                option.value = opt;
                option.innerText = opt.charAt(0).toUpperCase() + opt.slice(1);
                typeSelect.appendChild(option);
            });
            typeRow.appendChild(typeSelect);
            modal.appendChild(typeRow);

            // If prefill data is provided, populate the inputs and select accordingly.
            if (prefill) {
                // Code may be provided as combined string or separate parts; if we
                // have courseObj (the actual course object), we can use its
                // Major and Code fields to reconstruct the code. Otherwise use
                // prefill.code.
                if (courseObj && courseObj.Major && courseObj.Code) {
                    codeInput.value = courseObj.Major + courseObj.Code;
                } else if (prefill.code) {
                    codeInput.value = prefill.code;
                }
                if (courseObj && courseObj.Course_Name) {
                    nameInput.value = courseObj.Course_Name;
                } else if (prefill.name) {
                    nameInput.value = prefill.name;
                }
                if (courseObj && courseObj.SU_credit) {
                    suInput.value = courseObj.SU_credit;
                } else if (prefill.suCredits !== undefined) {
                    suInput.value = prefill.suCredits;
                }
                if (courseObj && courseObj.ECTS) {
                    ectsInput.value = courseObj.ECTS;
                } else if (prefill.ects !== undefined) {
                    ectsInput.value = prefill.ects;
                }
                if (courseObj && courseObj.Basic_Science !== undefined) {
                    bsInput.value = courseObj.Basic_Science;
                } else if (prefill.basicScience !== undefined) {
                    bsInput.value = prefill.basicScience;
                }
                if (courseObj && courseObj.Engineering !== undefined) {
                    engInput.value = courseObj.Engineering;
                } else if (prefill.engineering !== undefined) {
                    engInput.value = prefill.engineering;
                }
                // Set EL type dropdown
                if (courseObj && courseObj.EL_Type) {
                    typeSelect.value = courseObj.EL_Type;
                } else if (prefill.elType) {
                    typeSelect.value = prefill.elType;
                }
            }

        // Buttons container
        const buttonsRow = document.createElement('div');
        buttonsRow.classList.add('cc-buttons');

        const cancelBtn = document.createElement('button');
        cancelBtn.innerText = 'Cancel';
        cancelBtn.classList.add('btn', 'btn-secondary', 'btn-sm');
            cancelBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                overlay.remove();
                // On cancel, advance pending custom course processing if provided
                if (typeof onSaveCallback === 'function') {
                    onSaveCallback();
                }
            });
        buttonsRow.appendChild(cancelBtn);

        const saveBtn = document.createElement('button');
        saveBtn.innerText = 'Save';
        saveBtn.classList.add('btn', 'btn-primary', 'btn-sm');
            saveBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                // Read input values
                const rawCode = codeInput.value.trim().toUpperCase();
                if (!rawCode) {
                    uiAlert('Missing course code', '<p>Course code is required.</p>');
                    return;
                }
                // Parse major and numeric code from input (letters+digits)
                const match = rawCode.match(/^([A-Z]+)(\d+)$/);
                if (!match) {
                    uiAlert('Invalid course code', '<p>Invalid course code format. Use e.g. <strong>CS300</strong> or <strong>MATH101</strong>.</p>');
                    return;
                }
                const parsedMajor = match[1];
                const parsedCode = match[2];
                // Keep a reference to the course object we create or update so
                // that double major classification can reuse its credit values.
                let sourceForDM = courseObj || null;
                // Determine if we're updating an existing course or creating a new one
                if (courseObj) {
                    // Update fields on the existing course object
                    courseObj.Major = parsedMajor;
                    courseObj.Code = parsedCode;
                    courseObj.Course_Name = nameInput.value.trim() || rawCode;
                    courseObj.ECTS = ectsInput.value.toString() || '0';
                    courseObj.Engineering = parseInt(engInput.value || '0') || 0;
                    courseObj.Basic_Science = parseInt(bsInput.value || '0') || 0;
                    courseObj.SU_credit = suInput.value.toString() || '0';
                    courseObj.EL_Type = typeSelect.value;
                    // Persist update to localStorage
                    try {
                        const key = 'customCourses_' + major_chosen_by_user;
                        const existing = JSON.parse(planGetItem(key) || '[]');
                        // Find and update the matching course in storage
                        for (let i = 0; i < existing.length; i++) {
                            if (existing[i].Major === courseObj.Major && existing[i].Code === courseObj.Code) {
                                existing[i] = courseObj;
                                break;
                            }
                        }
                        planSetItem(key, JSON.stringify(existing));
                    } catch (ex) {
                        console.error('Failed to update custom course:', ex);
                    }
                } else {
                    // Build course object
                    const newCourse = {
                        Major: parsedMajor,
                        Code: parsedCode,
                        Course_Name: nameInput.value.trim() || rawCode,
                        ECTS: ectsInput.value.toString() || '0',
                        Engineering: parseInt(engInput.value || '0') || 0,
                        Basic_Science: parseInt(bsInput.value || '0') || 0,
                        SU_credit: suInput.value.toString() || '0',
                        Faculty: 'FENS',
                        EL_Type: typeSelect.value,
                        Faculty_Course: 'No'
                    };
                    // Append to in-memory course_data
                    course_data.push(newCourse);
                    sourceForDM = newCourse;
                    // Persist to localStorage under current major
                    try {
                        const key = 'customCourses_' + major_chosen_by_user;
                        const existing = JSON.parse(planGetItem(key) || '[]');
                        existing.push(newCourse);
                        planSetItem(key, JSON.stringify(existing));
                    } catch (ex) {
                        console.error('Failed to save custom course:', ex);
                    }
                }
                // Update any open dropdowns so the new or updated course appears as an option
                try {
                    const optionsHTML = getCoursesDataList(course_data);
                    document.querySelectorAll('datalist.course_list').forEach(function(dl) {
                        dl.innerHTML = optionsHTML;
                    });
                } catch (ex) {
                    // ignore if lists not present
                }
                // Recalculate effective types since new course attributes may affect totals
                try {
                    if (typeof curriculum.recalcEffectiveTypes === 'function') {
                        curriculum.recalcEffectiveTypes(course_data);
                    }
                } catch (err) {
                    // ignore
                }
                // Remove modal
                overlay.remove();
                // If a double major is selected, check if this course exists
                // in the double major course data.  If not, prompt the
                // user to assign a category for the double major.
                try {
                    if (curriculum.doubleMajor) {
                        // Determine combined code for the saved course
                        const combo = (courseObj ? (courseObj.Major + courseObj.Code) : (parsedMajor + parsedCode));
                        // Build a set of DM codes
                        const dmSet = new Set(doubleMajorCourseData.map(c => c.Major + c.Code));
                        if (!dmSet.has(combo)) {
                            // Determine course name for prompt
                            const nameForPrompt = courseObj ? (courseObj.Course_Name || combo) : (nameInput.value.trim() || combo);
                            showCourseTypeFormDM(combo, nameForPrompt, function(selectedType) {
                                if (selectedType) {
                                    // Create new DM course object using the same credit
                                    // values as the main custom course so that DM totals
                                    // count these credits correctly.
                                    const matchDM = combo.match(/^([A-Z]+)(\d+)/);
                                    const mDM = matchDM ? matchDM[1] : combo.replace(/\d+.*/, '');
                                    const nDM = matchDM ? matchDM[2] : combo.replace(/[A-Z]+/, '');
                                    const newCourseDM = {
                                        Major: mDM,
                                        Code: nDM,
                                        Course_Name: nameForPrompt,
                                        ECTS: sourceForDM ? String(sourceForDM.ECTS || '0') : '0',
                                        Engineering: sourceForDM ? parseFloat(sourceForDM.Engineering || '0') : 0,
                                        Basic_Science: sourceForDM ? parseFloat(sourceForDM.Basic_Science || '0') : 0,
                                        SU_credit: sourceForDM ? String(sourceForDM.SU_credit || '0') : '0',
                                        Faculty: '',
                                        EL_Type: selectedType,
                                        Faculty_Course: 'No'
                                    };
                                    doubleMajorCourseData.push(newCourseDM);
                                    // Persist DM custom course
                                    try {
                                        const keyDM = 'customCourses_' + curriculum.doubleMajor;
                                        const existingDM = JSON.parse(planGetItem(keyDM) || '[]');
                                        existingDM.push(newCourseDM);
                                        planSetItem(keyDM, JSON.stringify(existingDM));
                                    } catch (_) {}
                                    // Recalculate effective types for DM
                                    try {
                                        curriculum.recalcEffectiveTypesDouble(doubleMajorCourseData);
                                    } catch (_) {}
                                }
                            });
                        }
                    }
                } catch (ex) {
                    // ignore classification errors
                }
                // Invoke callback to process next pending custom course
                if (typeof onSaveCallback === 'function') {
                    onSaveCallback();
                }
            });
        buttonsRow.appendChild(saveBtn);

        modal.appendChild(buttonsRow);

        // Prevent overlay clicks from triggering underlying events
        modal.addEventListener('click', function(e) {
            e.stopPropagation();
        });

        // Append modal to overlay and overlay to board
        overlay.appendChild(modal);
        // Do not allow closing the form by clicking outside the modal
        overlay.addEventListener('click', function(e) {
            e.stopPropagation();
        });
        boardDom.appendChild(overlay);
    }

    // Bind custom course button click
    const customCourseBtn = document.querySelector('.customCourse');
    if (customCourseBtn) {
        customCourseBtn.addEventListener('click', function() {
            showCustomCourseForm();
        });
    }

    // Bind delete custom courses button click
    const deleteCustomBtn = document.querySelector('.deleteCustom');
    if (deleteCustomBtn) {
        deleteCustomBtn.addEventListener('click', function() {
            // async modal inside handler; no need to await here
            handleDeleteCustomCourses();
        });
    }
    // Bind reset local data button click
    const resetLocalBtn = document.querySelector('.resetLocal');
    if (resetLocalBtn) {
        resetLocalBtn.addEventListener('click', async function() {
            const ok = await uiConfirm(
                'Reset local data?',
                '<p>Are you sure you want to reset <strong>all</strong> local data?</p>' +
                '<p>This will remove saved semesters, custom courses, grades, and your saved plans.</p>',
                { confirmText: 'Reset', danger: true }
            );
            if (ok) {
                try {
                    // Explicitly remove all relevant keys from localStorage
                    planRemoveItem('curriculum');
                    planRemoveItem('grades');
                    planRemoveItem('dates');
                    const customKey = 'customCourses_' + major_chosen_by_user;
                    planRemoveItem(customKey);
                    clearInterval(saveInterval);
                    localStorage.clear();
                } catch (ex) {
                    console.error('Failed to clear localStorage:', ex);
                }
                // Reload the page to reflect the cleared state
                location.reload();
            }
        });
    }

    // The old 'Add Double Major' button functionality has been replaced
    // by a persistent dropdown created near the major display.  Any
    // unused event handlers referencing '.addDoubleMajor' are removed.

    //************************************************************** 

    //Reload items from local storage:
    reload(curriculum, course_data);
    // After reloading existing semesters, recalculate effective categories
    // so that the allocation respects chronological order. Guard against
    // missing recalc function.
    try {
        if (typeof curriculum.recalcEffectiveTypes === 'function') {
            curriculum.recalcEffectiveTypes(course_data);
        }
    } catch(err) {
        // ignore
    }
    // Ensure the ghost semester container is appended after reloading existing semesters
    ensureGhostSemester();
    //Save:
    saveInterval = setInterval(function() {
        planSetItem("curriculum", serializator(curriculum));
        planSetItem("grades", grades_serializator());
        planSetItem("dates", dates_serializator());
    }, 2000);

    // Allow the plan manager to force-flush state before switching/exporting.
    try {
        if (typeof window !== 'undefined' && window.planStorage && typeof window.planStorage.registerSaveHook === 'function') {
            window.planStorage.registerSaveHook(function() {
                planSetItem("curriculum", serializator(curriculum));
                planSetItem("grades", grades_serializator());
                planSetItem("dates", dates_serializator());
            });
        }
    } catch (_) {}

    //createSemeter(false, ["MATH101","MATH102","MATH201","MATH203","IF100","TLL101"], curriculum, course_data)
    //createSemeter(false, ["NS101","SPS101","SPS102","AL102","TLL102","HIST192","PROJ201", "NS102", "HIST191", "CIP101N", "CS210", "MATH306", "CS201", "CS204", "MATH204"], curriculum, course_data)

    // No debug alerts in production; remove for clean UI

        // Helper to sequentially process a list of pending custom courses.
        // Each entry should contain a `course` (reference to the course object
        // already added to course_data) and optionally a `parsedInfo` object
        // containing raw code/title/credits extracted from the transcript. The
        // function will show the custom course modal prefilled with the known
        // information and allow the user to complete any missing fields. Once
        // the user saves or cancels, the next pending course is processed.
        function processPendingCustomCourses(list) {
            if (!Array.isArray(list) || list.length === 0) return;
            const next = list.shift();
            const prefill = {};
            if (next.parsedInfo && next.parsedInfo.code) {
                prefill.code = next.parsedInfo.code;
            } else if (next.course && next.course.Major && next.course.Code) {
                prefill.code = next.course.Major + next.course.Code;
            }
            if (next.parsedInfo && next.parsedInfo.title) {
                prefill.name = next.parsedInfo.title;
            } else if (next.course && next.course.Course_Name) {
                prefill.name = next.course.Course_Name;
            }
            if (next.course) {
                prefill.suCredits = next.course.SU_credit;
                prefill.ects = next.course.ECTS;
                prefill.basicScience = next.course.Basic_Science;
                prefill.engineering = next.course.Engineering;
                prefill.elType = next.course.EL_Type;
            }
            // Show the custom course form. Pass the existing course object so
            // that the save handler updates it instead of creating a new one.
            showCustomCourseForm(prefill, next.course, function() {
                processPendingCustomCourses(list);
            });
        }

        /**
         * Process a queue of courses that are missing a double major category.
         * For each course code in the list, we prompt the user to select
         * a category (core/area/free/university/required).  Once the user
         * selects a type, we create a new course object for the double
         * major and append it to the double major course data and
         * localStorage.  After all items have been processed, we
         * recalculate effective types for the double major.
         * @param {Array} list - Array of objects { code, title }
         */
        function processPendingDoubleMajor(list) {
            if (!Array.isArray(list) || list.length === 0) {
                // After processing all, recalc double major categories and
                // update the datalist to include any courses defined via
                // DM classification.  This ensures newly added DM
                // custom courses appear in the selection dropdown.
                try {
                    curriculum.recalcEffectiveTypesDouble(doubleMajorCourseData);
                } catch (ex) {}
                // Refresh datalist with DM uniques
                updateDatalistForDoubleMajor();
                return;
            }
            const item = list.shift();
            showCourseTypeFormDM(item.code, item.title, function(selectedType) {
                if (selectedType) {
                    // Parse major prefix and code number
                    const match = item.code.match(/^([A-Z]+)(\d+)/);
                    const maj = match ? match[1] : item.code.replace(/\d+.*/, '');
                    const num = match ? match[2] : item.code.replace(/[A-Z]+/, '');
                    const newCourseDM = {
                        Major: maj,
                        Code: num,
                        Course_Name: item.title || item.code,
                        ECTS: '0',
                        Engineering: 0,
                        Basic_Science: 0,
                        SU_credit: '0',
                        Faculty: '',
                        EL_Type: selectedType,
                        Faculty_Course: 'No'
                    };
                    // Append to DM course data
                    doubleMajorCourseData.push(newCourseDM);
                    // Persist to custom courses storage for DM
                    try {
                        const keyDM = 'customCourses_' + curriculum.doubleMajor;
                        const existingDM = JSON.parse(planGetItem(keyDM) || '[]');
                        existingDM.push(newCourseDM);
                        planSetItem(keyDM, JSON.stringify(existingDM));
                    } catch (_) {}
                }
                // Process next
                processPendingDoubleMajor(list);
            });
        }

        /**
         * Show a modal to choose a category for a course under the double
         * major.  Only the category selector is presented; credits are
         * assumed to be zero by default.  On save, the callback is
         * invoked with the selected category; on cancel, callback is
         * invoked with null.
         * @param {string} code - The course code (e.g., CS101)
         * @param {string} title - The course name
         * @param {function} callback - Called with selected category or null
         */
        function showCourseTypeFormDM(code, title, callback) {
            // Avoid multiple modals
            if (document.querySelector('.double_major_modal')) return;
            const overlay = document.createElement('div');
            overlay.classList.add('double_major_overlay');
            const modal = document.createElement('div');
            modal.classList.add('double_major_modal');
            // Title
            const h = document.createElement('h3');
            h.innerText = 'Set Category for Double Major';
            modal.appendChild(h);
            // Info text
            const info = document.createElement('p');
            info.innerText = code + ' - ' + title;
            modal.appendChild(info);
            // Select
            const select = document.createElement('select');
            ['core','area','required','university','free','none'].forEach(function(opt) {
                const o = document.createElement('option');
                o.value = opt;
                o.innerText = opt.charAt(0).toUpperCase() + opt.slice(1);
                select.appendChild(o);
            });
            modal.appendChild(select);
            // Buttons
            const buttons = document.createElement('div');
            buttons.classList.add('dm-buttons');
            const save = document.createElement('button');
            save.innerText = 'Save';
            save.classList.add('btn', 'btn-primary', 'btn-sm');
            save.onclick = function(e) {
                e.stopPropagation();
                const chosen = select.value;
                overlay.remove();
                if (callback) callback(chosen);
            };
            buttons.appendChild(save);
            modal.appendChild(buttons);
            overlay.appendChild(modal);
            // Prevent closing the modal by clicking outside
            overlay.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            document.body.appendChild(overlay);
        }

        /**
         * Load and activate a double major.  This function fetches the course
         * data for the selected second major, loads any custom courses for
         * that major, and then recalculates effective types for the double
         * major.  It also scans existing courses in the curriculum to
         * identify any that do not yet exist in the double major course data
         * and prompts the user to classify them for the double major.
         * @param {string} dm - The double major code (e.g., EE)
         */
        function setDoubleMajor(dm) {
            curriculum.doubleMajor = dm;
            curriculum.entryTermDM = entryTermDMCode;
            // Attach the loaded DM course data to the curriculum so
            // recalcEffectiveTypes() can trigger DM recalculation automatically.
            // Fetch course data for second major
            fetchCourseData(dm, entryTermDMCode).then(function(jsonDM) {
                if (!jsonDM || jsonDM.length === 0) {
                    uiAlert(
                        'No course data',
                        `<p>No course data available for <strong>${escapeHtml(dm)}</strong> in <strong>${escapeHtml(termCodeToName(entryTermDMCode))}</strong>.</p>`
                    );
                }
                doubleMajorCourseData = jsonDM || [];
                // Save DM course data on the curriculum instance so
                // recalcEffectiveTypes() can trigger DM recalculation.
                curriculum.doubleMajorCourseData = doubleMajorCourseData;
                // Load custom courses for second major
                try {
                    const keyDM = 'customCourses_' + dm;
                    const storedDM = planGetItem(keyDM);
                    if (storedDM) {
                        const parsedDM = JSON.parse(storedDM);
                        if (Array.isArray(parsedDM)) {
                            doubleMajorCourseData = doubleMajorCourseData.concat(parsedDM);
                        }
                    }
                } catch (ex) {}
                // Recalc categories for DM
                curriculum.recalcEffectiveTypesDouble(doubleMajorCourseData);
                // Determine pending courses that need classification for DM
                const pending = [];
                const pendingSet = new Set();
                // Build a set of existing DM course codes for quick lookup
                const dmSet = new Set(doubleMajorCourseData.map(c => c.Major + c.Code));
                // Iterate all courses currently known (main + custom)
                course_data.forEach(function(c) {
                    const combined = (c.Major + c.Code);
                    if (!dmSet.has(combined)) {
                        let appears = false;
                        for (let si = 0; si < curriculum.semesters.length && !appears; si++) {
                            const sem = curriculum.semesters[si];
                            for (let ci = 0; ci < sem.courses.length; ci++) {
                                const sc = sem.courses[ci];
                                if ((sc.major + sc.code) === combined) {
                                    appears = true;
                                    break;
                                }
                            }
                        }
                        if (appears && !pendingSet.has(combined)) {
                            pending.push({ code: combined, title: c.Course_Name });
                            pendingSet.add(combined);
                        }
                    }
                });
                // Also include custom courses defined for the primary major even if not in semesters
                try {
                    const keyMain = 'customCourses_' + curriculum.major;
                    const storedMain = planGetItem(keyMain);
                    if (storedMain) {
                        const parsedMain = JSON.parse(storedMain);
                        if (Array.isArray(parsedMain)) {
                            parsedMain.forEach(function(cc){
                                const comb = cc.Major + cc.Code;
                                if (!dmSet.has(comb) && !pendingSet.has(comb)) {
                                    pending.push({ code: comb, title: cc.Course_Name });
                                    pendingSet.add(comb);
                                }
                            });
                        }
                    }
                } catch(_){}
                if (pending.length > 0) {
                    processPendingDoubleMajor(pending);
                }

                // After loading the double major data, update the course
                // selection datalist to include courses unique to the
                // double major.  We combine the primary major's
                // course_data with any DM course whose Major+Code
                // combination is not present in the primary data.  This
                // ensures the user can add DM-only courses while
                // maintaining separate credit calculations for the main
                // major.  Updating the datalist at this point allows
                // immediate selection of DM courses before any
                // pending classifications complete.  We will update
                // again after pending courses are classified (see below).
                updateDatalistForDoubleMajor();
            });
        }

        /**
         * Update the datalist for course selection when a double major is
         * active.  This helper builds a combined course list consisting
         * of the main major's courses plus any courses unique to the
         * double major (i.e., those not present in the main major's
         * course_data).  It then rebuilds the datalist options so that
         * users can select courses from either major.  Courses unique
         * to the double major will still be ignored for the main
         * major's category allocations (handled in recalcEffectiveTypes).
         */
        function updateDatalistForDoubleMajor() {
            try {
                // If no double major is selected, reset to primary data
                if (!curriculum.doubleMajor) {
                    const optionsHTML = getCoursesDataList(course_data);
                    document.querySelectorAll('datalist.course_list').forEach(function(dl) {
                        dl.innerHTML = optionsHTML;
                    });
                    return;
                }
                // Build a set of main course codes for quick lookup
                const mainSet = new Set(course_data.map(function(c) {
                    return (c.Major + c.Code);
                }));
                // Collect unique double major courses
                const dmUnique = [];
                doubleMajorCourseData.forEach(function(dm) {
                    const key = dm.Major + dm.Code;
                    if (!mainSet.has(key)) dmUnique.push(dm);
                });
                // Combine arrays
                const combined = course_data.concat(dmUnique);
                const html = getCoursesDataList(combined);
                document.querySelectorAll('datalist.course_list').forEach(function(dl) {
                    dl.innerHTML = html;
                });
            } catch (ex) {
                // ignore errors
            }
        }
        // Expose the helper globally so that other modules (e.g., the
        // curriculum code) can trigger datalist updates after reallocations.
        if (typeof window !== 'undefined') {
            window.updateDatalistForDoubleMajor = updateDatalistForDoubleMajor;
        }

        /**
         * Deletes all custom courses defined for the current major. Custom
         * courses are stored under the localStorage key `customCourses_<major>`.
         * This function removes those entries from both localStorage and the
         * in-memory `course_data` array. It also removes any instances of
         * those courses from the current curriculum's semesters. Finally it
         * updates the stored curriculum in localStorage and reloads the page
         * so that the UI reflects the changes. A confirmation prompt guards
         * against accidental deletion.
         */
        async function handleDeleteCustomCourses() {
            const keyMain = 'customCourses_' + major_chosen_by_user;
            const keyDM = curriculum.doubleMajor ? 'customCourses_' + curriculum.doubleMajor : null;

            let customMain = [];
            let customDM = [];
            try {
                customMain = JSON.parse(planGetItem(keyMain) || '[]');
            } catch (_) { customMain = []; }
            if (keyDM) {
                try {
                    customDM = JSON.parse(planGetItem(keyDM) || '[]');
                } catch (_) { customDM = []; }
            }

            if ((!customMain || customMain.length === 0) && (!customDM || customDM.length === 0)) {
                await uiAlert('No custom courses', '<p>There are no custom courses to delete for this plan.</p>');
                return;
            }

            let confirmMsg = 'Are you sure you want to delete all custom courses for ' + major_chosen_by_user;
            if (curriculum.doubleMajor) confirmMsg += ' and ' + curriculum.doubleMajor;
            confirmMsg += '?';
            if (!(await uiConfirm('Delete custom courses?', `<p>${escapeHtml(confirmMsg)}</p><p>This cannot be undone.</p>`, { confirmText: 'Delete', danger: true }))) {
                return;
            }

            const codeSetMain = new Set(customMain.map(c => c.Major + c.Code));
            const codeSetDM = new Set(customDM.map(c => c.Major + c.Code));
            const totalSet = new Set([...codeSetMain, ...codeSetDM]);

            course_data = course_data.filter(c => !codeSetMain.has(c.Major + c.Code));
            if (curriculum.doubleMajor) {
                doubleMajorCourseData = doubleMajorCourseData.filter(c => !codeSetDM.has(c.Major + c.Code));
                curriculum.doubleMajorCourseData = doubleMajorCourseData;
            }

            if (curriculum && Array.isArray(curriculum.semesters)) {
                curriculum.semesters.forEach(function(sem) {
                    if (Array.isArray(sem.courses)) {
                        sem.courses = sem.courses.filter(function(code) {
                            return !totalSet.has(code);
                        });
                    }
                });
            }

            try { planRemoveItem(keyMain); } catch (_) {}
            if (keyDM) { try { planRemoveItem(keyDM); } catch (_) {} }
            // Persist the updated curriculum to localStorage
            try {
                if (typeof serializator === 'function') {
                    planSetItem('curriculum', serializator(curriculum));
                }
            } catch (ex) {
                // ignore
            }
            // Recalculate effective types and update datalist
            try {
                if (typeof curriculum.recalcEffectiveTypes === 'function') {
                    curriculum.recalcEffectiveTypes(course_data);
                }
                if (curriculum.doubleMajor && typeof curriculum.recalcEffectiveTypesDouble === 'function') {
                    curriculum.recalcEffectiveTypesDouble(doubleMajorCourseData);
                }
                const optionsHTML = getCoursesDataList(course_data);
                document.querySelectorAll('datalist.course_list').forEach(function(dl) {
                    dl.innerHTML = optionsHTML;
                });
                if (curriculum.doubleMajor && typeof updateDatalistForDoubleMajor === 'function') {
                    updateDatalistForDoubleMajor();
                }
            } catch (err) {
                // ignore
            }
            // Reload the page to ensure UI reflects removed courses
            location.reload();
        }

        // Get from transcript:
        async function handleAcademicRecordsImport() {
        // Prevent import when semesters already exist, mirroring the
        // behaviour of the "Add First Year Courses" button.
        const existing = document.querySelectorAll('.semester');
        if (existing.length > 0) {
            const ui = (typeof window !== 'undefined') ? window.uiModal : null;
            const msg = '<p>Import only works when no semesters are present.</p><p>Please start a new plan or clear your semesters first.</p>';
            if (ui && typeof ui.alert === 'function') await ui.alert('Cannot import', msg);
            else await uiAlert('Cannot import', msg);
            return;
        }

        const fileInput = document.getElementById('academicRecordsInput');

        if (fileInput.files.length > 0) {
            const file = fileInput.files[0];
            let parsedData;

            try {
                const ui = (typeof window !== 'undefined') ? window.uiModal : null;
                const isDegreeEvaluation = (text) => {
                    try {
                        return /degree\s+evaluation/i.test(String(text || ''));
                    } catch (_) {
                        return false;
                    }
                };
                const isAcademicRecordsSummary = (text) => {
                    try {
                        return /academic\s+records\s+summary/i.test(String(text || ''));
                    } catch (_) {
                        return false;
                    }
                };
                const isYokTranscript = (text) => {
                    try {
                        const t = String(text || '');
                        return t.includes('NOT DKM BELGES') || t.includes('NOT DOKUM BELGESI');
                    } catch (_) {
                        return false;
                    }
                };
                const isNoPermissionHtml = (text) => {
                    try {
                        const t = String(text || '');
                        return t.includes('Sorry! You have no permission to access this page') ||
                               t.includes('You have no permission to access this page') ||
                               t.includes('Thanks for your patience') ||
                               t.includes('Information Technology</h3>');
                    } catch (_) {
                        return false;
                    }
                };
                const showDegreeEvalWarning = async () => {
                    const ui = (typeof window !== 'undefined') ? window.uiModal : null;
                    const title = 'Wrong file: Degree Evaluation';
                    const body = (
                        '<p>This looks like a <strong>Degree Evaluation</strong> document. SUrriculum can only import from your <strong>Academic Records Summary</strong>.</p>' +
                        '<p><strong>Please do not upload Degree Evaluation.</strong></p>' +
                        '<p>Please upload the correct file:</p>' +
                        '<ol>' +
                        '<li>Go to <strong>SUIS</strong>  <strong>Student</strong>  <strong>Student Records</strong>  <strong>Academic Transcript</strong></li>' +
                        '<li>Open your <strong>Academic Records Summary</strong></li>' +
                        '<li>Save it as <strong>HTML (preferred)</strong> or print to <strong>PDF</strong></li>' +
                        '<li>Upload that file here</li>' +
                        '</ol>' +
                        '<p>You can also upload your <strong>YK Transcript PDF</strong> (not preferred).</p>'
                    );
                    try { fileInput.value = ''; } catch (_) {}
                    try {
                        if (ui && typeof ui.alert === 'function') {
                            await ui.alert(title, body);
                        } else {
                            await uiAlert(title, body);
                        }
                    } catch (_) {}
                };
                const showHtmlSaveWarning = async () => {
                    const title = 'Cannot import this HTML file';
                    const body =
                        '<p>This HTML file does not contain your transcript data. This usually happens when you save the page as <strong>HTML only</strong> or when the saved page is missing required content.</p>' +
                        '<p>Please re-save your <strong>Academic Records Summary</strong> as:</p>' +
                        '<ol>' +
                        '<li>Open <strong>Academic Records Summary</strong> in SUIS (make sure you are logged in)</li>' +
                        '<li>Press <strong>Ctrl+S</strong> / <strong>Save Page As</strong></li>' +
                        '<li>Choose <strong>Webpage, Complete</strong> (not HTML only)</li>' +
                        '<li>Upload the saved <strong>.html</strong> file here</li>' +
                        '</ol>' +
                        '<p>Alternatively, print the same page to <strong>PDF</strong> and import that.</p>' +
                        '<p>You can also upload a <strong>YK Transcript PDF</strong> (not preferred).</p>';
                    try { fileInput.value = ''; } catch (_) {}
                    try {
                        if (ui && typeof ui.alert === 'function') await ui.alert(title, body);
                        else await uiAlert(title, body);
                    } catch (_) {}
                };

                if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument({ data: new Uint8Array(arrayBuffer) }).promise;
                    let text = '';
                    let totalTextItems = 0;

                    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                        const page = await pdf.getPage(pageNum);
                        const content = await page.getTextContent();
                        totalTextItems += (content.items && content.items.length) ? content.items.length : 0;
                        const strs = content.items.map(item => String(item.str || ''));
                        const totalLen = strs.reduce((acc, s) => acc + s.length, 0);
                        const avgLen = totalLen / Math.max(1, strs.length);
                        // Some PDFs (notably "Microsoft Print to PDF") yield character-level
                        // text items. Joining those with newlines destroys tokens. Use spaces
                        // in that case; otherwise preserve the previous newline behavior.
                        text += (avgLen <= 1.2 ? strs.join(' ') : strs.join('\n')) + '\n';
                    }
                    // Academic Records PDFs may mention Degree Evaluation at the end.
                    // Reject only if it looks like Degree Evaluation AND does not
                    // contain "Academic Records Summary". Never apply this to YK transcripts.
                    if (!isYokTranscript(text) && isDegreeEvaluation(text) && !isAcademicRecordsSummary(text)) {
                        await showDegreeEvalWarning();
                        return;
                    }
                    parsedData = window.academicRecordsParser.parseAcademicRecordsPdf(text);
                } else {
                    const htmlContent = await file.text();
                    if (isNoPermissionHtml(htmlContent)) {
                        await showHtmlSaveWarning();
                        return;
                    }
                    if (isDegreeEvaluation(htmlContent) && !isAcademicRecordsSummary(htmlContent)) {
                        await showDegreeEvalWarning();
                        return;
                    }
                    parsedData = window.academicRecordsParser.parseAcademicRecords(htmlContent);
                }
            } catch (err) {
                console.error(err);
                const ui = (typeof window !== 'undefined') ? window.uiModal : null;
                if (ui && typeof ui.alert === 'function') {
                    await ui.alert('Import failed', '<p>Failed to read the file.</p><p>Please try exporting again as HTML (preferred) or PDF.</p>');
                } else {
                    await uiAlert('Import failed', '<p>Failed to read the file.</p><p>Please try exporting again as HTML (preferred) or PDF.</p>');
                }
                return;
            }

            if (!parsedData || !Array.isArray(parsedData.courses) || parsedData.courses.length === 0) {
                const ui = (typeof window !== 'undefined') ? window.uiModal : null;
                try {
                    if (ui && typeof ui.alert === 'function') {
                        await ui.alert(
                            'No courses detected',
                            '<p>The file was read successfully, but no courses were detected.</p>' +
                            '<p>Make sure you upload the correct document:</p>' +
                            '<ol>' +
                            '<li>SUIS  Student  Student Records  Academic Transcript</li>' +
                            '<li>Open <strong>Academic Records Summary</strong> (not Degree Evaluation)</li>' +
                            '<li>Save as <strong>HTML</strong> (preferred) or print to <strong>PDF</strong></li>' +
                            '</ol>' +
                            '<p><strong>Important:</strong> Some PDFs created using <strong>Microsoft Print to PDF</strong> may not import correctly. If this happens, re-export the same page using <strong>Save as PDF</strong> (recommended) or save as <strong>HTML</strong> instead.</p>' +
                            '<p>If you are importing a <strong>YK Transcript PDF</strong>, ensure it is the NOT DKM BELGES format.</p>'
                        );
                    } else {
                        await uiAlert('No courses detected', '<p>No courses were detected in this file.</p>');
                    }
                } catch (_) {}
                return;
            }

            // Import courses to curriculum. The parser returns an object
            // containing both statistics and a list of pending custom
            // courses that need additional user input.
            const importResult = window.academicRecordsParser.importParsedCourses(
                parsedData.courses,
                course_data,
                curriculum
            );

            const importStats = importResult.stats;
            const pendingList = importResult.pendingCustomCourses || [];

            const ui = (typeof window !== 'undefined') ? window.uiModal : null;
            if (!importStats || typeof importStats.importedCourses !== 'number') {
                if (ui && typeof ui.alert === 'function') {
                    await ui.alert('Import failed', '<p>Import did not return results.</p>');
                } else {
                    await uiAlert('Import failed', '<p>Import did not return results.</p>');
                }
                return;
            }

            if (importStats.importedCourses === 0) {
                const body = (
                    `<p>No courses were imported.</p>` +
                    `<p>Detected <strong>${importStats.totalCourses || 0}</strong> course(s) in the file, but none could be added to your current plan.</p>` +
                    `<p>This usually happens if you selected the wrong major/double major before importing, or the file is not the Academic Records Summary.</p>` +
                    `<p>Please upload the correct file:</p>` +
                    '<ol>' +
                    '<li>SUIS  Student  Student Records  Academic Transcript</li>' +
                    '<li>Open <strong>Academic Records Summary</strong></li>' +
                    '<li>Save as <strong>HTML</strong> (preferred) or print to <strong>PDF</strong></li>' +
                    '<li>Upload that file here</li>' +
                    '</ol>' +
                    `<p>You can also upload a <strong>YK Transcript PDF</strong> (not preferred).</p>`
                );
                if (ui && typeof ui.alert === 'function') await ui.alert('No courses imported', body);
                else await uiAlert('No courses imported', body);
                return;
            }

            // Show import results to user
            const notFound = (importStats.notFoundCourses && importStats.notFoundCourses.length)
                ? `<p><strong>${importStats.notFoundCourses.length}</strong> course(s) were not found in the current program and were skipped:</p><p><small>${importStats.notFoundCourses.join(', ')}</small></p>`
                : '';
            const messageHtml = `<p>Successfully imported <strong>${importStats.importedCourses}</strong> of <strong>${importStats.totalCourses}</strong> course(s).</p>${notFound}`;
            if (ui && typeof ui.alert === 'function') await ui.alert('Import complete', messageHtml);
            else await uiAlert('Import complete', messageHtml);

            // If there are pending custom courses, process them
            if (pendingList.length > 0) {
                const queue = pendingList.slice();
                processPendingCustomCourses(queue);
            }
            const importDropdown = document.getElementById('importDropdown');
            if (importDropdown) importDropdown.classList.remove('active');
        } else {
            const ui = (typeof window !== 'undefined') ? window.uiModal : null;
            if (ui && typeof ui.alert === 'function') {
                await ui.alert('Select a file', '<p>Please select an <strong>Academic Records Summary</strong> HTML/PDF file (or a YK Transcript PDF) and try again.</p>');
            } else {
                await uiAlert('Select a file', '<p>Please select a file and try again.</p>');
            }
        }
    }
    document.getElementById('importAcademicRecords').onclick = handleAcademicRecordsImport;

    // Add event listener for the import toggle button
    document.querySelector('.import-toggle').addEventListener('click', function() {
        const dropdown = document.getElementById('importDropdown');
        if (dropdown) dropdown.classList.toggle('active');
    });

    // Close import panel when clicking outside
    document.addEventListener('click', function(e) {
        const dropdown = document.getElementById('importDropdown');
        const toggle = document.querySelector('.import-toggle');

        if (dropdown && dropdown.classList.contains('active') &&
            !dropdown.contains(e.target) &&
            !toggle.contains(e.target)) {
            dropdown.classList.remove('active');
        }
    });


    // At the end of initialization, if there is a saved double major in
    // localStorage, activate it.  This ensures the double major's
    // course categories are recalculated and displayed after the page
    // reloads.  We also update the select element's value to reflect
    // the stored double major choice.
    try {
        const savedDMInit = planGetItem('doubleMajor') || '';
        const dmSelect = document.querySelector('.doubleMajor');
        if (dmSelect && dmSelect.tagName === 'SELECT') {
            dmSelect.value = savedDMInit;
        }
        if (savedDMInit) {
            // setDoubleMajor expects uppercase codes
            setDoubleMajor(savedDMInit.toUpperCase());
        }
    } catch (e) {
        // ignore
    }

    //END OF PROGRAM
    })
    .catch(error => {
        console.error(error);
    });
}

let major_existing = planGetItem("major");
if (major_existing) {SUrriculum(major_existing);}
else {SUrriculum(initial_major_chosen);}
