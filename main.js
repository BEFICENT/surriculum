// Import statements removed. `s_curriculum` is expected to be defined
// globally by s_curriculum.js when loaded as a non-module script.

// Remove ES module imports for graduation_check. The functions
// displayGraduationResults and displaySummary will be attached to the
// global window object by graduation_check.js when loaded as a
// non-module script.

let course_data;
//can only be CS, BIO, MAT, EE, ME, IE, ECON, DSA, MAN, PSIR, PSY, VACD:
let initial_major_chosen = 'CS'
let saveInterval;

if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js');
    });
}


function SUrriculum(major_chosen_by_user) {
    /**
     * Attempt to fetch course data for the given major. By default the data
     * is expected to live under `./courses/${major}.json`, but in some
     * deployments the JSON files are present at the root (e.g., `./CS.json`).
     * This helper first tries the canonical location and falls back to the
     * root if the first fetch fails. It always returns a resolved Promise
     * with the parsed JSON or rejects if neither location is found.
     *
     * @param {string} major
     * @returns {Promise<Object[]>}
     */
    // Load mapping of available majors per term. Generated by the scraping
    // scripts and stored in courses/terms.json. This allows the major
    // selector to display only the programs offered in the chosen year.
    let majorsByTerm = {};
    try {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', './courses/terms.json', false);
        xhr.overrideMimeType('application/json');
        xhr.send(null);
        if (xhr.status === 200 || xhr.status === 0) {
            majorsByTerm = JSON.parse(xhr.responseText);
        }
    } catch (_) {}
    const defaultMajors = majorsByTerm['default'] || ['BIO','CS','EE','IE','MAT','ME','ECON','DSA','MAN','PSIR','PSY','VACD'];
    function getMajorsForTerm(code) {
        return majorsByTerm[code] || defaultMajors;
    }

    // Load course list for a specific major and term code (e.g. "202301").
    // Files are stored under courses/<term>/<major>.json. Fallback to the
    // root if the term-specific file is not found to preserve backward
    // compatibility with older deployments.
    function fetchCourseData(major, termCode) {
        // Build relative paths for the course JSON files. We avoid
        // computing absolute file URLs for file:// origins because
        // Chrome treats different file paths as different origins,
        // blocking cross-file requests. Using relative paths keeps
        // requests within the same origin (the directory of index.html).
        const primaryPath = `courses/${termCode}/${major}.json`;
        const fallbackPath = `courses/${major}.json`;
        const rootPath = `${major}.json`;

        // Helper to synchronously read JSON via XMLHttpRequest.  When
        // accessing resources under the file:// protocol many browsers
        // block fetch() due to CORS or security restrictions.  A
        // synchronous XHR is still permitted in these scenarios and
        // returns status 0 on success.  This helper returns a parsed
        // array of courses or null if the file could not be read.
        const tryRead = (path) => {
            try {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', path, false);
                xhr.overrideMimeType('application/json');
                xhr.send(null);
                if (xhr.status === 200 || xhr.status === 0) {
                    const parsed = JSON.parse(xhr.responseText);
                    return Array.isArray(parsed) ? parsed : [];
                }
            } catch (_) {
                // ignore errors and fall through
            }
            return null;
        };

        // Paths to attempt loading the course data.  We try the term
        // specific location first, followed by a fallback (no term) and
        // finally the root.  This preserves compatibility with older
        // deployments where the JSON files live in the top level.
        const paths = [primaryPath, fallbackPath, rootPath];

        // If running under file://, prefer synchronous XHR to bypass
        // fetch() restrictions.  We iterate each candidate path and
        // return on the first successful read.  If all attempts
        // fail, return an empty array.  For http(s) origins we still
        // attempt fetch() but only after synchronous reads fail.
        return (async () => {
            for (const p of paths) {
                const read = tryRead(p);
                if (read) {
                    return read;
                }
            }
            // If synchronous reads failed (likely under http(s)), fall
            // back to fetch.  Check res.ok and parse JSON.  Note: fetch
            // does not reject on 404; we must inspect ok.  If the
            // parsed value is not an array, return an empty list.
            for (const p of paths) {
                try {
                    const res = await fetch(p);
                    if (res.ok) {
                        const data = await res.json();
                        return Array.isArray(data) ? data : [];
                    }
                } catch (_) {
                    // ignore errors and continue
                }
            }
            return [];
        })();
    }
    // Determine entry terms for main and double majors from localStorage. The
    // terms are stored as display strings (e.g. "Fall 2023-2024"). We convert
    // them to numeric codes to locate the scraped JSON files.
    const entryTermName = localStorage.getItem('entryTerm') || entryTerms[0];
    const entryTermDMName = localStorage.getItem('entryTermDM') || entryTermName;
    const entryTermCode = termNameToCode(entryTermName);
    const entryTermDMCode = termNameToCode(entryTermDMName);

    // Storage for the double major's course data.  It will be populated when
    // the user selects a double major via setDoubleMajor().
    let doubleMajorCourseData = [];

    fetchCourseData(major_chosen_by_user, entryTermCode)
    .then(async json => {
        // If the course list could not be loaded, log a warning instead of
        // blocking the UI with an alert.  In some environments the
        // synchronous XHR may fail to resolve file:// URLs even when
        // the JSON exists, producing a false negative.  Logging a
        // warning allows the app to continue and display whatever
        // information could be retrieved.
        if (!json || json.length === 0) {
            console.warn('No course data available for ' + major_chosen_by_user + ' in ' + entryTermName + '.');
        }
    //START OF PROGRAM
        let change_major_element = document.querySelector('.change_major');
        let etElem = document.querySelector('.entryTerm');
        let etDmElem = document.querySelector('.entryTermDM');
        let dmElem = document.querySelector('.doubleMajor');
        // Populate and bind dropdown controls for major and entry terms
        if (change_major_element && change_major_element.tagName === 'SELECT') {
            const majorsList = getMajorsForTerm(entryTermCode);
            change_major_element.innerHTML = majorsList.map(m => `<option value="${m}">${m}</option>`).join('');
            change_major_element.value = major_chosen_by_user;
            change_major_element.addEventListener('change', function(e) {
                localStorage.setItem('major', e.target.value);
                location.reload();
            });
        }
        if (etElem && etElem.tagName === 'SELECT') {
            etElem.innerHTML = entryTerms.map(t => `<option value="${t}">${t}</option>`).join('');
            etElem.value = entryTermName;
            etElem.addEventListener('change', function(e) {
                localStorage.setItem('entryTerm', e.target.value);
                location.reload();
            });
        }
        if (dmElem && dmElem.tagName === 'SELECT') {
            const dmList = ['None'].concat(getMajorsForTerm(entryTermDMCode));
            dmElem.innerHTML = dmList.map(m => `<option value="${m === 'None' ? '' : m}">${m}</option>`).join('');
            dmElem.value = localStorage.getItem('doubleMajor') || '';
            dmElem.addEventListener('change', function(e) {
                const val = e.target.value;
                if (val) {
                    localStorage.setItem('doubleMajor', val);
                } else {
                    localStorage.removeItem('doubleMajor');
                }
                location.reload();
            });
        }
        if (etDmElem && etDmElem.tagName === 'SELECT') {
            etDmElem.innerHTML = entryTerms.map(t => `<option value="${t}">${t}</option>`).join('');
            etDmElem.value = entryTermDMName;
            etDmElem.addEventListener('change', function(e) {
                localStorage.setItem('entryTermDM', e.target.value);
                location.reload();
            });
        }

    course_data = json;

    // ----------------------------------------------------------------------
    // Load any previously defined custom courses for this major from
    // localStorage. Custom courses are stored as an array of course
    // objects keyed by `customCourses_<major>`. These custom courses are
    // appended to the fetched course_data. This allows users to define
    // additional courses specific to a major without modifying the
    // underlying JSON files. On first use, the key may not exist so
    // JSON.parse on an empty string would throw; guard accordingly.
    try {
        const customKey = 'customCourses_' + major_chosen_by_user;
        const stored = localStorage.getItem(customKey);
        if (stored) {
            const parsed = JSON.parse(stored);
            if (Array.isArray(parsed)) {
                course_data = course_data.concat(parsed);
            }
        }
    } catch (err) {
        console.error('Failed to load custom courses:', err);
    }

    // Preload double major data so that courses unique to the second major
    // are available when reloading semesters from localStorage.
    let savedDMPref = '';
    try {
        savedDMPref = localStorage.getItem('doubleMajor') || '';
    } catch (_) {}
    if (savedDMPref) {
        const dmData = await fetchCourseData(savedDMPref, entryTermDMCode);
        if (Array.isArray(dmData)) {
            doubleMajorCourseData = dmData.slice();
        } else {
            doubleMajorCourseData = [];
        }
        try {
            const keyDM = 'customCourses_' + savedDMPref;
            const storedDM = localStorage.getItem(keyDM);
            if (storedDM) {
                const parsedDM = JSON.parse(storedDM);
                if (Array.isArray(parsedDM)) {
                    doubleMajorCourseData = doubleMajorCourseData.concat(parsedDM);
                }
            }
        } catch (_) {}
    }
    let curriculum = new s_curriculum();
    curriculum.major = major_chosen_by_user;
    curriculum.entryTerm = entryTermCode;
    curriculum.entryTermDM = entryTermDMCode;
    if (savedDMPref) {
        curriculum.doubleMajorCourseData = doubleMajorCourseData;
        curriculum.doubleMajor = savedDMPref;
        curriculum.entryTermDM = entryTermDMCode;
    }

    // Expose the curriculum object globally so that helper functions
    // (e.g., isCourseValid and getInfo) can access the double major
    // configuration. This is especially useful for validating courses
    // that belong solely to the double major. Without this, helper
    // functions cannot see doubleMajorCourseData and would reject
    // double-major-specific courses.
    if (typeof window !== 'undefined') {
        window.curriculum = curriculum;
    }
    // Initialize course details toggle state and event
    let showDetails = false;
    try { showDetails = localStorage.getItem('showCourseDetails') === 'true'; } catch (_) {}
    if (typeof window !== 'undefined') {
        window.showCourseDetails = showDetails;
    }
    const detailsToggle = document.getElementById('courseDetailsToggle');
    if (detailsToggle) {
        detailsToggle.checked = showDetails;
        detailsToggle.addEventListener('change', function(e) {
            const enabled = e.target.checked;
            if (typeof window !== 'undefined') {
                window.showCourseDetails = enabled;
            }
            try { localStorage.setItem('showCourseDetails', enabled ? 'true' : 'false'); } catch (_) {}
            document.dispatchEvent(new Event('courseDetailsToggleChanged'));
        });
    }

    //************************************************

    //Targetting dynamically created elements:
    document.addEventListener('click', function(e){
        dynamic_click(e, curriculum, course_data);
        if (!(e.target.parentNode.classList.contains('summary_modal_child')) &&
            !e.target.classList.contains('summary_modal_child') &&
            !e.target.classList.contains('summary_modal') &&
            !e.target.classList.contains('summary') &&
            !e.target.classList.contains('summary_p')) {
            try { document.querySelectorAll('.summary_modal').forEach(function(mod){ mod.remove(); }); } catch {}
            try { document.querySelectorAll('.summary_modal_overlay').forEach(function(ov){ ov.remove(); }); } catch {}
        }
        if(!(e.target.parentNode.classList.contains('graduation_modal')) && !e.target.classList.contains('graduation_modal') && !e.target.classList.contains('check') && !e.target.parentNode.classList.contains('check')) {
            try{document.querySelector('.graduation_modal').remove();} catch{}
            try{document.querySelector('.graduation_modal_overlay').remove();} catch{}
        }
    });
    document.addEventListener('mouseover', function(e){
        mouseover(e);
        if (e.target.classList.contains('btn'))
        {e.target.style.backgroundColor = '#7a9dc9';}
        else if(e.target.parentNode.classList && e.target.parentNode.classList.contains('btn'))
        {e.target.parentNode.style.backgroundColor = '#7a9dc9';}
        else
        {
            document.querySelectorAll('.btn').forEach( element => {element.style.backgroundColor = '#526e8f'});
        }
    })
    document.addEventListener('mouseout', function(e){
        mouseout(e);
        if (e.target.classList.contains('btn'))
        {e.target.style.backgroundColor = '#526e8f';}
    })

    let dragged_item = null;
    document.addEventListener('dragstart', function(e){
        if(e.target.classList.contains("container_semester"))
        {dragged_item = e.target;}
    })
    document.addEventListener('dragover', function(e){
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    })

    document.addEventListener('drop', function(e){
        // Pass course_data to the drop handler so that it can invoke
        // curriculum.recalcEffectiveTypes() when semesters are reordered.
        drop(e, curriculum, dragged_item, course_data);
    })

    // Touch-based dragging support mirrors the desktop drag events so that
    // semesters can be reordered on touch devices.  We leverage touch
    // coordinates on touchend to determine the drop target and prevent the
    // page from scrolling while a semester is being dragged.
    document.addEventListener('touchstart', function(e){
        // Only begin dragging if the user taps the dedicated drag handle.
        const handle = getAncestor(e.target, 'semester_drag');
        if(handle){
            dragged_item = getAncestor(handle, 'container_semester');
        }
    })
    document.addEventListener('touchmove', function(e){
        if(dragged_item){
            // Prevent viewport scrolling while dragging a semester
            e.preventDefault();
        }
    }, {passive:false})
    document.addEventListener('touchend', function(e){
        if(dragged_item){
            const touch = e.changedTouches[0];
            drop(e, curriculum, dragged_item, course_data, {x: touch.clientX, y: touch.clientY});
            dragged_item = null;
        }
    })
    /*
    document.addEventListener("input", function(e){
        if(e.target.classList.contains())
    })*/

    //************************************************************** 

    //NON-DYNAMIC BUTTONS:
    const addSemester = document.querySelector(".addSemester");
    addSemester.addEventListener('click', function(){
        const board = document.querySelector('.board');
        const newContainer = createSemeter(true, [], curriculum, course_data);
        const ghost = document.querySelector('.add-semester-ghost');
        if (ghost && board) {
            board.insertBefore(newContainer, ghost);
            const style = getComputedStyle(newContainer);
            const width = newContainer.offsetWidth + parseInt(style.marginLeft) + parseInt(style.marginRight);
            board.scrollBy({ left: width, behavior: 'smooth' });
        }
    });

    function ensureGhostSemester() {
        const board = document.querySelector('.board');
        if (!board) return;
        let ghost = board.querySelector('.add-semester-ghost');
        if (!ghost) {
            ghost = document.createElement('div');
            ghost.classList.add('add-semester-ghost');
            ghost.textContent = '+ New Semester';
            ghost.addEventListener('click', function() {
                const newContainer = createSemeter(true, [], curriculum, course_data);
                const style = getComputedStyle(newContainer);
                const width = newContainer.offsetWidth + parseInt(style.marginLeft) + parseInt(style.marginRight);
                board.insertBefore(newContainer, ghost);
                board.scrollBy({ left: width, behavior: 'smooth' });
            });
            board.appendChild(ghost);
        }
    }

    // Sidebar collapse toggle
    const sidebar = document.querySelector('.sidebar');
    const sidebarToggle = document.querySelector('.sidebar-toggle');
    if (sidebar && sidebarToggle) {
        sidebarToggle.addEventListener('click', function() {
            sidebar.classList.toggle('collapsed');
        });
    }

    const auto_add = document.querySelector('.autoAdd');
    auto_add.addEventListener('click', function(){
        // Check if there are existing semesters
        const semesters = document.querySelectorAll('.semester');
        if (semesters.length > 0) {
            alert('Error: Add First Year Courses only works when no semesters are present.');
            return;
        }

        // Determine the user's entry term so that the automatically added
        // semesters start from that term rather than the earliest term in
        // the list (Fall 2019-2020).
        const entryTerm = localStorage.getItem('entryTerm') || entryTerms[0];
        const entryCode = termNameToCode(entryTerm);

        // Helper to compute the next chronological term code
        function nextTermCode(code) {
            const term = code.slice(4);
            const year = parseInt(code.slice(0, 4), 10);
            if (term === '01') return String(year) + '02'; // Fall -> Spring
            // Summer -> Fall of next academic year
            return String(year + 1) + '01';
        }

        const nextCode = nextTermCode(entryCode);
        const nextTerm = termCodeToName(nextCode);

        // Automatically insert the typical first year courses into two semesters.
        let fs_courses = ["MATH101","NS101","SPS101","IF100","TLL101","HIST191","CIP101N"];
        let ss_courses = ["MATH102","NS102","SPS102","AL102","TLL102","HIST192","PROJ201"];

        // Insert the next term first so that the entry term ends up at the top
        // of the board. Pass explicit term names to createSemeter so that the
        // semesters use the correct dates.
        createSemeter(false, ss_courses, curriculum, course_data, [], nextTerm);
        createSemeter(false, fs_courses, curriculum, course_data, [], entryTerm);
    })

    // Older markup wrapped the text inside a <p> tag. Guard against that
    // structure to avoid errors when clicking the button in the new UI.
    const checkText = document.querySelector('.check>p');
    if (checkText) {
        checkText.addEventListener('click', function(){
            document.querySelector('.check').click();
        });
    }
    const check_graduation = document.querySelector('.check');
    check_graduation.addEventListener('click', function(){
        displayGraduationResults(curriculum);
    })

    const summary = document.querySelector('.summary');
    summary.addEventListener('click', function(){
        displaySummary(curriculum, major_chosen_by_user);
    })

    // ----------------------------------------------------------------------
    // Custom Course: create a modal form to let the user define a new
    // course. The new course is stored in localStorage under a key
    // specific to the current major (customCourses_<major>) and added to
    // course_data. Existing datalists are updated so the new course can
    // be selected immediately. Only one custom course modal can be open
    // at a time.
        function showCustomCourseForm(prefill = null, courseObj = null, onSaveCallback = null) {
            // Prevent multiple modals
            if (document.querySelector('.custom_course_modal')) return;

        // Append overlay to body so it covers the full viewport
        const boardDom = document.body;

        // Create overlay container
        const overlay = document.createElement('div');
        overlay.classList.add('custom_course_overlay');

        // Create modal container
        const modal = document.createElement('div');
        modal.classList.add('custom_course_modal');

        // Title
        const title = document.createElement('h3');
        title.innerText = 'Add Custom Course';
        modal.appendChild(title);

        // Helper to create input row
        function createInputRow(labelText, inputType = 'text', placeholder = '', defaultValue = '') {
            const row = document.createElement('div');
            row.classList.add('cc-row');

            const label = document.createElement('label');
            label.innerText = labelText;
            row.appendChild(label);

            const input = document.createElement('input');
            input.type = inputType;
            input.placeholder = placeholder;
            input.value = defaultValue;
            row.appendChild(input);

            return { row, input };
        }

            // Course Code input (e.g., CS101)
            const { row: codeRow, input: codeInput } = createInputRow('Course Code:', 'text', 'e.g. CS300');
            modal.appendChild(codeRow);

            // Course Name input
            const { row: nameRow, input: nameInput } = createInputRow('Course Name:', 'text', 'Course name');
            modal.appendChild(nameRow);

            // SU Credits input
            const { row: suRow, input: suInput } = createInputRow('SU Credits:', 'number', 'e.g. 3');
            modal.appendChild(suRow);

            // ECTS input
            const { row: ectsRow, input: ectsInput } = createInputRow('ECTS:', 'number', 'e.g. 6');
            modal.appendChild(ectsRow);

            // Basic Science credits input
            const { row: bsRow, input: bsInput } = createInputRow('Basic Science credits:', 'number', 'e.g. 0');
            bsInput.value = '0';
            modal.appendChild(bsRow);

            // Engineering credits input
            const { row: engRow, input: engInput } = createInputRow('Engineering credits:', 'number', 'e.g. 0');
            engInput.value = '0';
            modal.appendChild(engRow);

            // EL Type dropdown
            const typeRow = document.createElement('div');
            typeRow.classList.add('cc-row');
            const typeLabel = document.createElement('label');
            typeLabel.innerText = 'Category (EL_Type):';
            typeRow.appendChild(typeLabel);
            const typeSelect = document.createElement('select');
            ['core', 'area', 'university', 'free', 'required', 'none'].forEach(function(opt) {
                const option = document.createElement('option');
                option.value = opt;
                option.innerText = opt.charAt(0).toUpperCase() + opt.slice(1);
                typeSelect.appendChild(option);
            });
            typeRow.appendChild(typeSelect);
            modal.appendChild(typeRow);

            // If prefill data is provided, populate the inputs and select accordingly.
            if (prefill) {
                // Code may be provided as combined string or separate parts; if we
                // have courseObj (the actual course object), we can use its
                // Major and Code fields to reconstruct the code. Otherwise use
                // prefill.code.
                if (courseObj && courseObj.Major && courseObj.Code) {
                    codeInput.value = courseObj.Major + courseObj.Code;
                } else if (prefill.code) {
                    codeInput.value = prefill.code;
                }
                if (courseObj && courseObj.Course_Name) {
                    nameInput.value = courseObj.Course_Name;
                } else if (prefill.name) {
                    nameInput.value = prefill.name;
                }
                if (courseObj && courseObj.SU_credit) {
                    suInput.value = courseObj.SU_credit;
                } else if (prefill.suCredits !== undefined) {
                    suInput.value = prefill.suCredits;
                }
                if (courseObj && courseObj.ECTS) {
                    ectsInput.value = courseObj.ECTS;
                } else if (prefill.ects !== undefined) {
                    ectsInput.value = prefill.ects;
                }
                if (courseObj && courseObj.Basic_Science !== undefined) {
                    bsInput.value = courseObj.Basic_Science;
                } else if (prefill.basicScience !== undefined) {
                    bsInput.value = prefill.basicScience;
                }
                if (courseObj && courseObj.Engineering !== undefined) {
                    engInput.value = courseObj.Engineering;
                } else if (prefill.engineering !== undefined) {
                    engInput.value = prefill.engineering;
                }
                // Set EL type dropdown
                if (courseObj && courseObj.EL_Type) {
                    typeSelect.value = courseObj.EL_Type;
                } else if (prefill.elType) {
                    typeSelect.value = prefill.elType;
                }
            }

        // Buttons container
        const buttonsRow = document.createElement('div');
        buttonsRow.classList.add('cc-buttons');

        const cancelBtn = document.createElement('button');
        cancelBtn.innerText = 'Cancel';
        cancelBtn.classList.add('btn', 'btn-secondary', 'btn-sm');
            cancelBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                overlay.remove();
                // On cancel, advance pending custom course processing if provided
                if (typeof onSaveCallback === 'function') {
                    onSaveCallback();
                }
            });
        buttonsRow.appendChild(cancelBtn);

        const saveBtn = document.createElement('button');
        saveBtn.innerText = 'Save';
        saveBtn.classList.add('btn', 'btn-primary', 'btn-sm');
            saveBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                // Read input values
                const rawCode = codeInput.value.trim().toUpperCase();
                if (!rawCode) {
                    alert('Course code is required.');
                    return;
                }
                // Parse major and numeric code from input (letters+digits)
                const match = rawCode.match(/^([A-Z]+)(\d+)$/);
                if (!match) {
                    alert('Invalid course code format. Use e.g. CS300 or MATH101.');
                    return;
                }
                const parsedMajor = match[1];
                const parsedCode = match[2];
                // Keep a reference to the course object we create or update so
                // that double major classification can reuse its credit values.
                let sourceForDM = courseObj || null;
                // Determine if we're updating an existing course or creating a new one
                if (courseObj) {
                    // Update fields on the existing course object
                    courseObj.Major = parsedMajor;
                    courseObj.Code = parsedCode;
                    courseObj.Course_Name = nameInput.value.trim() || rawCode;
                    courseObj.ECTS = ectsInput.value.toString() || '0';
                    courseObj.Engineering = parseInt(engInput.value || '0') || 0;
                    courseObj.Basic_Science = parseInt(bsInput.value || '0') || 0;
                    courseObj.SU_credit = suInput.value.toString() || '0';
                    courseObj.EL_Type = typeSelect.value;
                    // Persist update to localStorage
                    try {
                        const key = 'customCourses_' + major_chosen_by_user;
                        const existing = JSON.parse(localStorage.getItem(key) || '[]');
                        // Find and update the matching course in storage
                        for (let i = 0; i < existing.length; i++) {
                            if (existing[i].Major === courseObj.Major && existing[i].Code === courseObj.Code) {
                                existing[i] = courseObj;
                                break;
                            }
                        }
                        localStorage.setItem(key, JSON.stringify(existing));
                    } catch (ex) {
                        console.error('Failed to update custom course:', ex);
                    }
                } else {
                    // Build course object
                    const newCourse = {
                        Major: parsedMajor,
                        Code: parsedCode,
                        Course_Name: nameInput.value.trim() || rawCode,
                        ECTS: ectsInput.value.toString() || '0',
                        Engineering: parseInt(engInput.value || '0') || 0,
                        Basic_Science: parseInt(bsInput.value || '0') || 0,
                        SU_credit: suInput.value.toString() || '0',
                        Faculty: 'FENS',
                        EL_Type: typeSelect.value,
                        Faculty_Course: 'No'
                    };
                    // Append to in-memory course_data
                    course_data.push(newCourse);
                    sourceForDM = newCourse;
                    // Persist to localStorage under current major
                    try {
                        const key = 'customCourses_' + major_chosen_by_user;
                        const existing = JSON.parse(localStorage.getItem(key) || '[]');
                        existing.push(newCourse);
                        localStorage.setItem(key, JSON.stringify(existing));
                    } catch (ex) {
                        console.error('Failed to save custom course:', ex);
                    }
                }
                // Update any open dropdowns so the new or updated course appears as an option
                try {
                    const optionsHTML = getCoursesDataList(course_data);
                    document.querySelectorAll('datalist.course_list').forEach(function(dl) {
                        dl.innerHTML = optionsHTML;
                    });
                } catch (ex) {
                    // ignore if lists not present
                }
                // Recalculate effective types since new course attributes may affect totals
                try {
                    if (typeof curriculum.recalcEffectiveTypes === 'function') {
                        curriculum.recalcEffectiveTypes(course_data);
                    }
                } catch (err) {
                    // ignore
                }
                // Remove modal
                overlay.remove();
                // If a double major is selected, check if this course exists
                // in the double major course data.  If not, prompt the
                // user to assign a category for the double major.
                try {
                    if (curriculum.doubleMajor) {
                        // Determine combined code for the saved course
                        const combo = (courseObj ? (courseObj.Major + courseObj.Code) : (parsedMajor + parsedCode));
                        // Build a set of DM codes
                        const dmSet = new Set(doubleMajorCourseData.map(c => c.Major + c.Code));
                        if (!dmSet.has(combo)) {
                            // Determine course name for prompt
                            const nameForPrompt = courseObj ? (courseObj.Course_Name || combo) : (nameInput.value.trim() || combo);
                            showCourseTypeFormDM(combo, nameForPrompt, function(selectedType) {
                                if (selectedType) {
                                    // Create new DM course object using the same credit
                                    // values as the main custom course so that DM totals
                                    // count these credits correctly.
                                    const matchDM = combo.match(/^([A-Z]+)(\d+)/);
                                    const mDM = matchDM ? matchDM[1] : combo.replace(/\d+.*/, '');
                                    const nDM = matchDM ? matchDM[2] : combo.replace(/[A-Z]+/, '');
                                    const newCourseDM = {
                                        Major: mDM,
                                        Code: nDM,
                                        Course_Name: nameForPrompt,
                                        ECTS: sourceForDM ? String(sourceForDM.ECTS || '0') : '0',
                                        Engineering: sourceForDM ? parseFloat(sourceForDM.Engineering || '0') : 0,
                                        Basic_Science: sourceForDM ? parseFloat(sourceForDM.Basic_Science || '0') : 0,
                                        SU_credit: sourceForDM ? String(sourceForDM.SU_credit || '0') : '0',
                                        Faculty: '',
                                        EL_Type: selectedType,
                                        Faculty_Course: 'No'
                                    };
                                    doubleMajorCourseData.push(newCourseDM);
                                    // Persist DM custom course
                                    try {
                                        const keyDM = 'customCourses_' + curriculum.doubleMajor;
                                        const existingDM = JSON.parse(localStorage.getItem(keyDM) || '[]');
                                        existingDM.push(newCourseDM);
                                        localStorage.setItem(keyDM, JSON.stringify(existingDM));
                                    } catch (_) {}
                                    // Recalculate effective types for DM
                                    try {
                                        curriculum.recalcEffectiveTypesDouble(doubleMajorCourseData);
                                    } catch (_) {}
                                }
                            });
                        }
                    }
                } catch (ex) {
                    // ignore classification errors
                }
                // Invoke callback to process next pending custom course
                if (typeof onSaveCallback === 'function') {
                    onSaveCallback();
                }
            });
        buttonsRow.appendChild(saveBtn);

        modal.appendChild(buttonsRow);

        // Prevent overlay clicks from triggering underlying events
        modal.addEventListener('click', function(e) {
            e.stopPropagation();
        });

        // Append modal to overlay and overlay to board
        overlay.appendChild(modal);
        // Do not allow closing the form by clicking outside the modal
        overlay.addEventListener('click', function(e) {
            e.stopPropagation();
        });
        boardDom.appendChild(overlay);
    }

    // Bind custom course button click
    const customCourseBtn = document.querySelector('.customCourse');
    if (customCourseBtn) {
        customCourseBtn.addEventListener('click', function() {
            showCustomCourseForm();
        });
    }

    // Bind delete custom courses button click
    const deleteCustomBtn = document.querySelector('.deleteCustom');
    if (deleteCustomBtn) {
        deleteCustomBtn.addEventListener('click', function() {
            handleDeleteCustomCourses();
        });
    }
    // Bind reset local data button click
    const resetLocalBtn = document.querySelector('.resetLocal');
    if (resetLocalBtn) {
        resetLocalBtn.addEventListener('click', function() {
            if (confirm('Are you sure you want to reset all local data? This will remove all saved semesters, custom courses, and grades.')) {
                try {
                    // Explicitly remove all relevant keys from localStorage
                    localStorage.removeItem('curriculum');
                    localStorage.removeItem('grades');
                    localStorage.removeItem('dates');
                    const customKey = 'customCourses_' + major_chosen_by_user;
                    localStorage.removeItem(customKey);
                    clearInterval(saveInterval);
                    localStorage.clear();
                } catch (ex) {
                    console.error('Failed to clear localStorage:', ex);
                }
                // Reload the page to reflect the cleared state
                location.reload();
            }
        });
    }

    // The old 'Add Double Major' button functionality has been replaced
    // by a persistent dropdown created near the major display.  Any
    // unused event handlers referencing '.addDoubleMajor' are removed.

    //************************************************************** 

    //Reload items from local storage:
    reload(curriculum, course_data);
    // After reloading existing semesters, recalculate effective categories
    // so that the allocation respects chronological order. Guard against
    // missing recalc function.
    try {
        if (typeof curriculum.recalcEffectiveTypes === 'function') {
            curriculum.recalcEffectiveTypes(course_data);
        }
    } catch(err) {
        // ignore
    }
    // Ensure the ghost semester container is appended after reloading existing semesters
    ensureGhostSemester();
    //Save:
    saveInterval = setInterval(function() {
        localStorage.removeItem("curriculum");
        localStorage.setItem("curriculum", serializator(curriculum));
        localStorage.removeItem("grades");
        localStorage.setItem("grades", grades_serializator());
        localStorage.removeItem("dates");
        localStorage.setItem("dates", dates_serializator());
    }, 2000);

    //createSemeter(false, ["MATH101","MATH102","MATH201","MATH203","IF100","TLL101"], curriculum, course_data)
    //createSemeter(false, ["NS101","SPS101","SPS102","AL102","TLL102","HIST192","PROJ201", "NS102", "HIST191", "CIP101N", "CS210", "MATH306", "CS201", "CS204", "MATH204"], curriculum, course_data)

    // No debug alerts in production; remove for clean UI

        // Helper to sequentially process a list of pending custom courses.
        // Each entry should contain a `course` (reference to the course object
        // already added to course_data) and optionally a `parsedInfo` object
        // containing raw code/title/credits extracted from the transcript. The
        // function will show the custom course modal prefilled with the known
        // information and allow the user to complete any missing fields. Once
        // the user saves or cancels, the next pending course is processed.
        function processPendingCustomCourses(list) {
            if (!Array.isArray(list) || list.length === 0) return;
            const next = list.shift();
            const prefill = {};
            if (next.parsedInfo && next.parsedInfo.code) {
                prefill.code = next.parsedInfo.code;
            } else if (next.course && next.course.Major && next.course.Code) {
                prefill.code = next.course.Major + next.course.Code;
            }
            if (next.parsedInfo && next.parsedInfo.title) {
                prefill.name = next.parsedInfo.title;
            } else if (next.course && next.course.Course_Name) {
                prefill.name = next.course.Course_Name;
            }
            if (next.course) {
                prefill.suCredits = next.course.SU_credit;
                prefill.ects = next.course.ECTS;
                prefill.basicScience = next.course.Basic_Science;
                prefill.engineering = next.course.Engineering;
                prefill.elType = next.course.EL_Type;
            }
            // Show the custom course form. Pass the existing course object so
            // that the save handler updates it instead of creating a new one.
            showCustomCourseForm(prefill, next.course, function() {
                processPendingCustomCourses(list);
            });
        }

        /**
         * Process a queue of courses that are missing a double major category.
         * For each course code in the list, we prompt the user to select
         * a category (core/area/free/university/required).  Once the user
         * selects a type, we create a new course object for the double
         * major and append it to the double major course data and
         * localStorage.  After all items have been processed, we
         * recalculate effective types for the double major.
         * @param {Array} list - Array of objects { code, title }
         */
        function processPendingDoubleMajor(list) {
            if (!Array.isArray(list) || list.length === 0) {
                // After processing all, recalc double major categories and
                // update the datalist to include any courses defined via
                // DM classification.  This ensures newly added DM
                // custom courses appear in the selection dropdown.
                try {
                    curriculum.recalcEffectiveTypesDouble(doubleMajorCourseData);
                } catch (ex) {}
                // Refresh datalist with DM uniques
                updateDatalistForDoubleMajor();
                return;
            }
            const item = list.shift();
            showCourseTypeFormDM(item.code, item.title, function(selectedType) {
                if (selectedType) {
                    // Parse major prefix and code number
                    const match = item.code.match(/^([A-Z]+)(\d+)/);
                    const maj = match ? match[1] : item.code.replace(/\d+.*/, '');
                    const num = match ? match[2] : item.code.replace(/[A-Z]+/, '');
                    const newCourseDM = {
                        Major: maj,
                        Code: num,
                        Course_Name: item.title || item.code,
                        ECTS: '0',
                        Engineering: 0,
                        Basic_Science: 0,
                        SU_credit: '0',
                        Faculty: '',
                        EL_Type: selectedType,
                        Faculty_Course: 'No'
                    };
                    // Append to DM course data
                    doubleMajorCourseData.push(newCourseDM);
                    // Persist to custom courses storage for DM
                    try {
                        const keyDM = 'customCourses_' + curriculum.doubleMajor;
                        const existingDM = JSON.parse(localStorage.getItem(keyDM) || '[]');
                        existingDM.push(newCourseDM);
                        localStorage.setItem(keyDM, JSON.stringify(existingDM));
                    } catch (_) {}
                }
                // Process next
                processPendingDoubleMajor(list);
            });
        }

        /**
         * Show a modal to choose a category for a course under the double
         * major.  Only the category selector is presented; credits are
         * assumed to be zero by default.  On save, the callback is
         * invoked with the selected category; on cancel, callback is
         * invoked with null.
         * @param {string} code - The course code (e.g., CS101)
         * @param {string} title - The course name
         * @param {function} callback - Called with selected category or null
         */
        function showCourseTypeFormDM(code, title, callback) {
            // Avoid multiple modals
            if (document.querySelector('.double_major_modal')) return;
            const overlay = document.createElement('div');
            overlay.classList.add('double_major_overlay');
            const modal = document.createElement('div');
            modal.classList.add('double_major_modal');
            // Title
            const h = document.createElement('h3');
            h.innerText = 'Set Category for Double Major';
            modal.appendChild(h);
            // Info text
            const info = document.createElement('p');
            info.innerText = code + ' - ' + title;
            modal.appendChild(info);
            // Select
            const select = document.createElement('select');
            ['core','area','required','university','free','none'].forEach(function(opt) {
                const o = document.createElement('option');
                o.value = opt;
                o.innerText = opt.charAt(0).toUpperCase() + opt.slice(1);
                select.appendChild(o);
            });
            modal.appendChild(select);
            // Buttons
            const buttons = document.createElement('div');
            buttons.classList.add('dm-buttons');
            const save = document.createElement('button');
            save.innerText = 'Save';
            save.classList.add('btn', 'btn-primary', 'btn-sm');
            save.onclick = function(e) {
                e.stopPropagation();
                const chosen = select.value;
                overlay.remove();
                if (callback) callback(chosen);
            };
            buttons.appendChild(save);
            modal.appendChild(buttons);
            overlay.appendChild(modal);
            // Prevent closing the modal by clicking outside
            overlay.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            document.body.appendChild(overlay);
        }

        /**
         * Load and activate a double major.  This function fetches the course
         * data for the selected second major, loads any custom courses for
         * that major, and then recalculates effective types for the double
         * major.  It also scans existing courses in the curriculum to
         * identify any that do not yet exist in the double major course data
         * and prompts the user to classify them for the double major.
         * @param {string} dm - The double major code (e.g., EE)
         */
        function setDoubleMajor(dm) {
            curriculum.doubleMajor = dm;
            curriculum.entryTermDM = entryTermDMCode;
            // Attach the loaded DM course data to the curriculum so
            // recalcEffectiveTypes() can trigger DM recalculation automatically.
            // Fetch course data for second major
            fetchCourseData(dm, entryTermDMCode).then(function(jsonDM) {
                if (!jsonDM || jsonDM.length === 0) {
                    alert('No course data available for ' + dm + ' in ' + termCodeToName(entryTermDMCode));
                }
                doubleMajorCourseData = jsonDM || [];
                // Save DM course data on the curriculum instance so
                // recalcEffectiveTypes() can trigger DM recalculation.
                curriculum.doubleMajorCourseData = doubleMajorCourseData;
                // Load custom courses for second major
                try {
                    const keyDM = 'customCourses_' + dm;
                    const storedDM = localStorage.getItem(keyDM);
                    if (storedDM) {
                        const parsedDM = JSON.parse(storedDM);
                        if (Array.isArray(parsedDM)) {
                            doubleMajorCourseData = doubleMajorCourseData.concat(parsedDM);
                        }
                    }
                } catch (ex) {}
                // Recalc categories for DM
                curriculum.recalcEffectiveTypesDouble(doubleMajorCourseData);
                // Determine pending courses that need classification for DM
                const pending = [];
                const pendingSet = new Set();
                // Build a set of existing DM course codes for quick lookup
                const dmSet = new Set(doubleMajorCourseData.map(c => c.Major + c.Code));
                // Iterate all courses currently known (main + custom)
                course_data.forEach(function(c) {
                    const combined = (c.Major + c.Code);
                    if (!dmSet.has(combined)) {
                        let appears = false;
                        for (let si = 0; si < curriculum.semesters.length && !appears; si++) {
                            const sem = curriculum.semesters[si];
                            for (let ci = 0; ci < sem.courses.length; ci++) {
                                const sc = sem.courses[ci];
                                if ((sc.major + sc.code) === combined) {
                                    appears = true;
                                    break;
                                }
                            }
                        }
                        if (appears && !pendingSet.has(combined)) {
                            pending.push({ code: combined, title: c.Course_Name });
                            pendingSet.add(combined);
                        }
                    }
                });
                // Also include custom courses defined for the primary major even if not in semesters
                try {
                    const keyMain = 'customCourses_' + curriculum.major;
                    const storedMain = localStorage.getItem(keyMain);
                    if (storedMain) {
                        const parsedMain = JSON.parse(storedMain);
                        if (Array.isArray(parsedMain)) {
                            parsedMain.forEach(function(cc){
                                const comb = cc.Major + cc.Code;
                                if (!dmSet.has(comb) && !pendingSet.has(comb)) {
                                    pending.push({ code: comb, title: cc.Course_Name });
                                    pendingSet.add(comb);
                                }
                            });
                        }
                    }
                } catch(_){}
                if (pending.length > 0) {
                    processPendingDoubleMajor(pending);
                }

                // After loading the double major data, update the course
                // selection datalist to include courses unique to the
                // double major.  We combine the primary major's
                // course_data with any DM course whose Major+Code
                // combination is not present in the primary data.  This
                // ensures the user can add DM-only courses while
                // maintaining separate credit calculations for the main
                // major.  Updating the datalist at this point allows
                // immediate selection of DM courses before any
                // pending classifications complete.  We will update
                // again after pending courses are classified (see below).
                updateDatalistForDoubleMajor();
            });
        }

        /**
         * Update the datalist for course selection when a double major is
         * active.  This helper builds a combined course list consisting
         * of the main major's courses plus any courses unique to the
         * double major (i.e., those not present in the main major's
         * course_data).  It then rebuilds the datalist options so that
         * users can select courses from either major.  Courses unique
         * to the double major will still be ignored for the main
         * major's category allocations (handled in recalcEffectiveTypes).
         */
        function updateDatalistForDoubleMajor() {
            try {
                // If no double major is selected, reset to primary data
                if (!curriculum.doubleMajor) {
                    const optionsHTML = getCoursesDataList(course_data);
                    document.querySelectorAll('datalist.course_list').forEach(function(dl) {
                        dl.innerHTML = optionsHTML;
                    });
                    return;
                }
                // Build a set of main course codes for quick lookup
                const mainSet = new Set(course_data.map(function(c) {
                    return (c.Major + c.Code);
                }));
                // Collect unique double major courses
                const dmUnique = [];
                doubleMajorCourseData.forEach(function(dm) {
                    const key = dm.Major + dm.Code;
                    if (!mainSet.has(key)) dmUnique.push(dm);
                });
                // Combine arrays
                const combined = course_data.concat(dmUnique);
                const html = getCoursesDataList(combined);
                document.querySelectorAll('datalist.course_list').forEach(function(dl) {
                    dl.innerHTML = html;
                });
            } catch (ex) {
                // ignore errors
            }
        }
        // Expose the helper globally so that other modules (e.g., the
        // curriculum code) can trigger datalist updates after reallocations.
        if (typeof window !== 'undefined') {
            window.updateDatalistForDoubleMajor = updateDatalistForDoubleMajor;
        }

        /**
         * Deletes all custom courses defined for the current major. Custom
         * courses are stored under the localStorage key `customCourses_<major>`.
         * This function removes those entries from both localStorage and the
         * in-memory `course_data` array. It also removes any instances of
         * those courses from the current curriculum's semesters. Finally it
         * updates the stored curriculum in localStorage and reloads the page
         * so that the UI reflects the changes. A confirmation prompt guards
         * against accidental deletion.
         */
        function handleDeleteCustomCourses() {
            const keyMain = 'customCourses_' + major_chosen_by_user;
            const keyDM = curriculum.doubleMajor ? 'customCourses_' + curriculum.doubleMajor : null;

            let customMain = [];
            let customDM = [];
            try {
                customMain = JSON.parse(localStorage.getItem(keyMain) || '[]');
            } catch (_) { customMain = []; }
            if (keyDM) {
                try {
                    customDM = JSON.parse(localStorage.getItem(keyDM) || '[]');
                } catch (_) { customDM = []; }
            }

            if ((!customMain || customMain.length === 0) && (!customDM || customDM.length === 0)) {
                alert('There are no custom courses to delete for this major.');
                return;
            }

            let confirmMsg = 'Are you sure you want to delete all custom courses for ' + major_chosen_by_user;
            if (curriculum.doubleMajor) confirmMsg += ' and ' + curriculum.doubleMajor;
            confirmMsg += '?';
            if (!confirm(confirmMsg)) {
                return;
            }

            const codeSetMain = new Set(customMain.map(c => c.Major + c.Code));
            const codeSetDM = new Set(customDM.map(c => c.Major + c.Code));
            const totalSet = new Set([...codeSetMain, ...codeSetDM]);

            course_data = course_data.filter(c => !codeSetMain.has(c.Major + c.Code));
            if (curriculum.doubleMajor) {
                doubleMajorCourseData = doubleMajorCourseData.filter(c => !codeSetDM.has(c.Major + c.Code));
                curriculum.doubleMajorCourseData = doubleMajorCourseData;
            }

            if (curriculum && Array.isArray(curriculum.semesters)) {
                curriculum.semesters.forEach(function(sem) {
                    if (Array.isArray(sem.courses)) {
                        sem.courses = sem.courses.filter(function(code) {
                            return !totalSet.has(code);
                        });
                    }
                });
            }

            try { localStorage.removeItem(keyMain); } catch (_) {}
            if (keyDM) { try { localStorage.removeItem(keyDM); } catch (_) {} }
            // Persist the updated curriculum to localStorage
            try {
                if (typeof serializator === 'function') {
                    localStorage.removeItem('curriculum');
                    localStorage.setItem('curriculum', serializator(curriculum));
                }
            } catch (ex) {
                // ignore
            }
            // Recalculate effective types and update datalist
            try {
                if (typeof curriculum.recalcEffectiveTypes === 'function') {
                    curriculum.recalcEffectiveTypes(course_data);
                }
                if (curriculum.doubleMajor && typeof curriculum.recalcEffectiveTypesDouble === 'function') {
                    curriculum.recalcEffectiveTypesDouble(doubleMajorCourseData);
                }
                const optionsHTML = getCoursesDataList(course_data);
                document.querySelectorAll('datalist.course_list').forEach(function(dl) {
                    dl.innerHTML = optionsHTML;
                });
                if (curriculum.doubleMajor && typeof updateDatalistForDoubleMajor === 'function') {
                    updateDatalistForDoubleMajor();
                }
            } catch (err) {
                // ignore
            }
            // Reload the page to ensure UI reflects removed courses
            location.reload();
        }

        // Get from transcript:
        async function handleAcademicRecordsImport() {
        // Prevent import when semesters already exist, mirroring the
        // behaviour of the "Add First Year Courses" button.
        const existing = document.querySelectorAll('.semester');
        if (existing.length > 0) {
            alert('Error: Import only works when no semesters are present.');
            return;
        }

        const fileInput = document.getElementById('academicRecordsInput');

        if (fileInput.files.length > 0) {
            const file = fileInput.files[0];
            let parsedData;

            try {
                if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument({ data: new Uint8Array(arrayBuffer) }).promise;
                    let text = '';
                    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                        const page = await pdf.getPage(pageNum);
                        const content = await page.getTextContent();
                        text += content.items.map(item => item.str).join('\n') + '\n';
                    }
                    parsedData = window.academicRecordsParser.parseAcademicRecordsPdf(text);
                } else {
                    const htmlContent = await file.text();
                    parsedData = window.academicRecordsParser.parseAcademicRecords(htmlContent);
                }
            } catch (err) {
                console.error(err);
                alert('Failed to read academic records file.');
                return;
            }

            // Import courses to curriculum. The parser returns an object
            // containing both statistics and a list of pending custom
            // courses that need additional user input.
            const importResult = window.academicRecordsParser.importParsedCourses(
                parsedData.courses,
                course_data,
                curriculum
            );

            const importStats = importResult.stats;
            const pendingList = importResult.pendingCustomCourses || [];

            // Show import results to user
            let message = `Successfully imported ${importStats.importedCourses} of ${importStats.totalCourses} courses.`;

            if (importStats.notFoundCourses.length > 0) {
                message += `\n\nThe following ${importStats.notFoundCourses.length} courses were not found in the current program and were not imported:\n${importStats.notFoundCourses.join(', ')}`;
            }

            alert(message);

            // If there are pending custom courses, process them
            if (pendingList.length > 0) {
                const queue = pendingList.slice();
                processPendingCustomCourses(queue);
            }
            const importDropdown = document.getElementById('importDropdown');
            if (importDropdown) importDropdown.classList.remove('active');
        } else {
            alert('Please select an Academic Records HTML or PDF file.');
        }
    }
    document.getElementById('importAcademicRecords').onclick = handleAcademicRecordsImport;

    // Add event listener for the import toggle button
    document.querySelector('.import-toggle').addEventListener('click', function() {
        const dropdown = document.getElementById('importDropdown');
        if (dropdown) dropdown.classList.toggle('active');
    });

    // Close import panel when clicking outside
    document.addEventListener('click', function(e) {
        const dropdown = document.getElementById('importDropdown');
        const toggle = document.querySelector('.import-toggle');

        if (dropdown && dropdown.classList.contains('active') &&
            !dropdown.contains(e.target) &&
            !toggle.contains(e.target)) {
            dropdown.classList.remove('active');
        }
    });


    // At the end of initialization, if there is a saved double major in
    // localStorage, activate it.  This ensures the double major's
    // course categories are recalculated and displayed after the page
    // reloads.  We also update the select element's value to reflect
    // the stored double major choice.
    try {
        const savedDMInit = localStorage.getItem('doubleMajor') || '';
        const dmSelect = document.querySelector('.doubleMajor');
        if (dmSelect && dmSelect.tagName === 'SELECT') {
            dmSelect.value = savedDMInit;
        }
        if (savedDMInit) {
            // setDoubleMajor expects uppercase codes
            setDoubleMajor(savedDMInit.toUpperCase());
        }
    } catch (e) {
        // ignore
    }

    //END OF PROGRAM
    })
    .catch(error => {
        console.error(error);
    });
}

let major_existing = localStorage.getItem("major");
if (major_existing) {SUrriculum(major_existing);}
else {SUrriculum(initial_major_chosen);}